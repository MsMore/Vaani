import e from"react";import r from"isoworker";import n from"dequal";const t=e=>r=>{const[n]=r.data;return Promise.resolve(e.fn(...n)).then(r=>{const n="auto"===e.transferable&&(t=r,"ArrayBuffer"in self&&t instanceof ArrayBuffer||"MessagePort"in self&&t instanceof MessagePort||"ImageBitmap"in self&&t instanceof ImageBitmap||"OffscreenCanvas"in self&&t instanceof OffscreenCanvas)?[r]:[];var t;postMessage(["SUCCESS",r],n)}).catch(e=>{postMessage(["ERROR",e])})},a=(e,n,a,o)=>{const[s]=r.createContext(o),c=`\n    ${(e=>0===e.length?"":`importScripts('${e.map(e=>""+e).toString()}')`)(n)};\n    ${s}\n    onmessage=(${t})({\n      fn: (${e}),\n      transferable: '${a}'\n    })\n  `,u=new Blob([c],{type:"text/javascript"});return URL.createObjectURL(u)};var o;!function(e){e.PENDING="PENDING",e.SUCCESS="SUCCESS",e.RUNNING="RUNNING",e.ERROR="ERROR",e.TIMEOUT_EXPIRED="TIMEOUT_EXPIRED"}(o||(o={}));var s,c=o;!function(e){e.AUTO="auto",e.NONE="none"}(s||(s={}));const u={timeout:void 0,remoteDependencies:[],autoTerminate:!0,transferable:s.AUTO,localDependencies:()=>[]},i=(r,t=u)=>{const[o,i]=e.useState(c.PENDING),l=e.useRef(),f=e.useRef(!1),m=e.useRef({}),R=e.useRef(),d=e.useCallback(e=>{f.current=e===c.RUNNING,i(e)},[]),p=e.useCallback(()=>{var e;(null===(e=l.current)||void 0===e?void 0:e._url)&&(l.current.terminate(),URL.revokeObjectURL(l.current._url),m.current={},l.current=void 0,window.clearTimeout(R.current))},[]),v=e.useCallback(e=>{(null!=t.autoTerminate?t.autoTerminate:u.autoTerminate)&&p(),d(e)},[t.autoTerminate,p,d]),E=((o,s)=>{const i=e.useRef(s);return n(i.current,s)||(i.current=s),e.useCallback(()=>{const{remoteDependencies:e=u.remoteDependencies,timeout:n=u.timeout,transferable:o=u.transferable,localDependencies:s=u.localDependencies}=t,i=a(r,e,o,s),l=new Worker(i);return l._url=i,l.onmessage=e=>{var r,n,t,a;const[o,s]=e.data;switch(o){case c.SUCCESS:null===(r=(n=m.current).resolve)||void 0===r||r.call(n,s),v(c.SUCCESS);break;default:null===(t=(a=m.current).reject)||void 0===t||t.call(a,s),v(c.ERROR)}},l.onerror=e=>{var r,n;null===(r=(n=m.current).reject)||void 0===r||r.call(n,e),v(c.ERROR)},n&&(R.current=window.setTimeout(()=>{p(),d(c.TIMEOUT_EXPIRED)},n)),l},i.current)})(0,[r,t,p]),w=e.useCallback((...e)=>{const{transferable:r=u.transferable}=t;return new Promise((n,t)=>{var a;m.current={resolve:n,reject:t};const o=r===s.AUTO?e.filter(e=>"ArrayBuffer"in window&&e instanceof ArrayBuffer||"MessagePort"in window&&e instanceof MessagePort||"ImageBitmap"in window&&e instanceof ImageBitmap||"OffscreenCanvas"in window&&e instanceof OffscreenCanvas):[];null===(a=l.current)||void 0===a||a.postMessage([[...e]],o),d(c.RUNNING)})},[d]),C=e.useCallback((...e)=>{const r=null!=t.autoTerminate?t.autoTerminate:u.autoTerminate;return f.current?(console.error("[useWorker] You can only run one instance of the worker at a time, if you want to run more than one in parallel, create another instance with the hook useWorker(). Read more: https://github.com/alewin/useWorker"),Promise.reject()):(!r&&l.current||(l.current=E()),w(...e))},[t.autoTerminate,E,w]),N={status:o,kill:p};return e.useEffect(()=>()=>{p()},[p]),[C,N]};export{o as WORKER_STATUS,i as useWorker};
//# sourceMappingURL=index.modern.js.map
