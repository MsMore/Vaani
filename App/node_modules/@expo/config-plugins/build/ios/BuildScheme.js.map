{"version":3,"file":"BuildScheme.js","sourceRoot":"","sources":["../../src/ios/BuildScheme.ts"],"names":[],"mappings":";;;;;AAAA,gDAAwB;AAExB,sCAA4C;AAC5C,mCAA2D;AAqB3D,SAAgB,uBAAuB,CAAC,WAAmB;IACzD,OAAO,uBAAe,CAAC,WAAW,CAAC,CAAC;AACtC,CAAC;AAFD,0DAEC;AAEM,KAAK,UAAU,kCAAkC,CACtD,WAAmB,EACnB,MAAc;;IAEd,MAAM,cAAc,GAAG,uBAAe,CAAC,WAAW,CAAC,CAAC;IACpD,MAAM,EAAE,GAAG,IAAI,MAAM,CAAC,IAAI,MAAM,WAAW,CAAC,CAAC;IAC7C,MAAM,UAAU,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACxD,IAAI,CAAC,UAAU,EAAE;QACf,MAAM,IAAI,KAAK,CAAC,WAAW,MAAM,kBAAkB,CAAC,CAAC;KACtD;IAED,MAAM,SAAS,GAAI,CAAC,MAAM,kBAAY,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAA0B,CAAC;IACvF,MAAM,gBAAgB,iCACpB,SAAS,CAAC,MAAM,0CAAE,WAAW,0CAAG,CAAC,2CAAG,kBAAkB,0CAAG,CAAC,2CAAG,gBAAgB,CAAC;IAChF,MAAM,UAAU,GACd,CAAA,gBAAgB,aAAhB,gBAAgB,uBAAhB,gBAAgB,CAAE,MAAM,MAAK,CAAC;QAC5B,CAAC,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;QACvC,CAAC,CAAC,gBAAgB,CACd,gBAAgB,aAAhB,gBAAgB,uBAAhB,gBAAgB,CAAE,IAAI,CAAC,KAAK,CAAC,EAAE;;YAC7B,+BAAO,KAAK,CAAC,kBAAkB,0CAAG,CAAC,2CAAI,GAAG,2CAAG,aAAa,0CAAE,QAAQ,CAAC,MAAM,EAAE;QAC/E,CAAC,EACF,CAAC;IACR,IAAI,CAAC,UAAU,EAAE;QACf,MAAM,kBAAkB,GAAG,cAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;QAClE,MAAM,IAAI,KAAK,CAAC,GAAG,kBAAkB,wBAAwB,CAAC,CAAC;KAChE;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AA3BD,gFA2BC;AAED,SAAS,gBAAgB,CAAC,KAA4B;;IACpD,yBAAO,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,kBAAkB,0CAAG,CAAC,2CAAI,GAAG,2CAAG,aAAa,CAAC;AAC9D,CAAC","sourcesContent":["import path from 'path';\n\nimport { readXMLAsync } from '../utils/XML';\nimport { findSchemeNames, findSchemePaths } from './Paths';\n\ninterface SchemeXML {\n  Scheme?: {\n    BuildAction?: {\n      BuildActionEntries?: {\n        BuildActionEntry?: BuildActionEntryType[];\n      }[];\n    }[];\n  };\n}\n\ninterface BuildActionEntryType {\n  BuildableReference?: {\n    $?: {\n      BlueprintName?: string;\n      BuildableName?: string;\n    };\n  }[];\n}\n\nexport function getSchemesFromXcodeproj(projectRoot: string): string[] {\n  return findSchemeNames(projectRoot);\n}\n\nexport async function getApplicationTargetForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const allSchemePaths = findSchemePaths(projectRoot);\n  const re = new RegExp(`/${scheme}.xcscheme`);\n  const schemePath = allSchemePaths.find(i => re.exec(i));\n  if (!schemePath) {\n    throw new Error(`scheme '${scheme}' does not exist`);\n  }\n\n  const schemeXML = ((await readXMLAsync({ path: schemePath })) as unknown) as SchemeXML;\n  const buildActionEntry =\n    schemeXML.Scheme?.BuildAction?.[0]?.BuildActionEntries?.[0]?.BuildActionEntry;\n  const targetName =\n    buildActionEntry?.length === 1\n      ? getBlueprintName(buildActionEntry[0])\n      : getBlueprintName(\n          buildActionEntry?.find(entry => {\n            return entry.BuildableReference?.[0]?.['$']?.BuildableName?.endsWith('.app');\n          })\n        );\n  if (!targetName) {\n    const schemeRelativePath = path.relative(projectRoot, schemePath);\n    throw new Error(`${schemeRelativePath} seems to be corrupted`);\n  }\n  return targetName;\n}\n\nfunction getBlueprintName(entry?: BuildActionEntryType): string | undefined {\n  return entry?.BuildableReference?.[0]?.['$']?.BlueprintName;\n}\n"]}