{"version":3,"file":"plugin-resolver.js","sourceRoot":"","sources":["../../src/utils/plugin-resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import findUp from 'find-up';\nimport * as path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { assert, PluginError } from './errors';\nimport { fileExists } from './modules';\n\n// Default plugin entry file name.\nexport const pluginFileName = 'app.plugin.js';\n\nfunction findUpPackageJson(root: string): string {\n  const packageJson = findUp.sync('package.json', { cwd: root });\n  assert(packageJson, `No package.json found for module \"${root}\"`);\n  return packageJson;\n}\n\nfunction resolvePluginForModule(projectRoot: string, modulePath: string): string {\n  const resolved = resolveFrom(projectRoot, modulePath);\n  assert(\n    resolved,\n    `Failed to resolve plugin for module \"${modulePath}\" relative to \"${projectRoot}\"`\n  );\n  // If the modulePath is something like `@bacon/package/index.js` or `expo-foo/build/app`\n  // then skip resolving the module `app.plugin.js`\n  if (moduleNameIsDirectFileReference(modulePath)) {\n    return resolved;\n  }\n  return findUpPlugin(resolved);\n}\n\n// TODO: Test windows\nfunction pathIsFilePath(name: string): boolean {\n  // Matches lines starting with: . / ~/\n  return !!name.match(/^(\\.|~\\/|\\/)/g);\n}\n\nexport function moduleNameIsDirectFileReference(name: string): boolean {\n  if (pathIsFilePath(name)) {\n    return true;\n  }\n\n  const slashCount = name.split(path.sep)?.length;\n  // Orgs (like @expo/config ) should have more than one slash to be a direct file.\n  if (name.startsWith('@')) {\n    return slashCount > 2;\n  }\n\n  // Regular packages should be considered direct reference if they have more than one slash.\n  return slashCount > 1;\n}\n\nfunction resolveExpoPluginFile(root: string): string | null {\n  // Find the expo plugin root file\n  const pluginModuleFile = resolveFrom.silent(\n    root,\n    // use ./ so it isn't resolved as a node module\n    `./${pluginFileName}`\n  );\n\n  // If the default expo plugin file exists use it.\n  if (pluginModuleFile && fileExists(pluginModuleFile)) {\n    return pluginModuleFile;\n  }\n  return null;\n}\n\nfunction findUpPlugin(root: string): string {\n  // Get the closest package.json to the node module\n  const packageJson = findUpPackageJson(root);\n  // resolve the root folder for the node module\n  const moduleRoot = path.dirname(packageJson);\n  // use whatever the initial resolved file was ex: `node_modules/my-package/index.js` or `./something.js`\n  return resolveExpoPluginFile(moduleRoot) ?? root;\n}\n\nexport function normalizeStaticPlugin(plugin: StaticPlugin | ConfigPlugin | string): StaticPlugin {\n  if (Array.isArray(plugin)) {\n    assert(\n      plugin.length > 0 && plugin.length < 3,\n      `Wrong number of arguments provided for static config plugin, expected either 1 or 2, got ${plugin.length}`\n    );\n    return plugin;\n  }\n  return [plugin, undefined];\n}\n\nexport function assertInternalProjectRoot(projectRoot?: string): asserts projectRoot {\n  assert(\n    projectRoot,\n    `Unexpected: Config \\`_internal.projectRoot\\` isn't defined by expo-cli, this is a bug.`\n  );\n}\n\n// Resolve the module function and assert type\nexport function resolveConfigPluginFunction(projectRoot: string, pluginModulePath: string) {\n  const moduleFilePath = resolvePluginForModule(projectRoot, pluginModulePath);\n  const result = requirePluginFile(moduleFilePath);\n  return resolveConfigPluginExport(result, moduleFilePath);\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n */\nexport function resolveConfigPluginExport(result: any, configFile: string): ConfigPlugin<unknown> {\n  if (result.default != null) {\n    result = result.default;\n  }\n  if (typeof result !== 'function') {\n    throw new PluginError(\n      `Plugin file ${configFile} must export a function. Learn more: https://github.com/expo/expo-cli/tree/master/packages/config-plugins#creating-a-plugin`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  return result;\n}\n\nfunction requirePluginFile(filePath: string): any {\n  try {\n    return require(filePath);\n  } catch (error) {\n    // TODO: Improve error messages\n    throw error;\n  }\n}\n"]}