/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,a){"object"==typeof exports&&"undefined"!=typeof module?a(exports,require("@tensorflow/tfjs-core"),require("seedrandom")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","seedrandom"],a):a((e=e||self).tf=e.tf||{},e.tf,e.seedrandom)}(this,(function(e,a,t){"use strict";var n=function(e,a){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,a){e.__proto__=a}||function(e,a){for(var t in a)a.hasOwnProperty(t)&&(e[t]=a[t])})(e,a)};function r(e,a,t,n){return new(t||(t=Promise))((function(r,i){function s(e){try{u(n.next(e))}catch(e){i(e)}}function o(e){try{u(n.throw(e))}catch(e){i(e)}}function u(e){var a;e.done?r(e.value):(a=e.value,a instanceof t?a:new t((function(e){e(a)}))).then(s,o)}u((n=n.apply(e,a||[])).next())}))}function i(e,a){var t,n,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function o(i){return function(o){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;s;)try{if(t=1,n&&(r=2&i[0]?n.return:i[0]?n.throw||((r=n.return)&&r.call(n),0):n.next)&&!(r=r.call(n,i[1])).done)return r;switch(n=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,n=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!(r=s.trys,(r=r.length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=a.call(e,s)}catch(e){i=[6,e],n=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,o])}}}function s(e,t){Array.isArray(e)||(e=[e]),e.forEach((function(e){null!=e&&a.util.assert("complex64"!==e.dtype,(function(){return t+" does not support complex64 tensors in the CPU backend."}))}))}var o=a.kernel_impls.whereImpl,u=function(e){function t(){var t=e.call(this)||this;return t.blockSize=48,t.firstUse=!0,t.data=new a.DataStorage(t,a.engine()),t}return function(e,a){function t(){this.constructor=e}n(e,a),e.prototype=null===a?Object.create(a):(t.prototype=a.prototype,new t)}(t,e),t.prototype.nextDataId=function(){return t.nextDataId++},t.prototype.write=function(e,t,n){this.firstUse&&(this.firstUse=!1,a.env().get("IS_NODE")&&a.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r},t.prototype.makeTensorInfo=function(e,t,n){var r;if("string"===t&&null!=n&&n.length>0&&a.util.isString(n[0])){var i=n.map((function(e){return a.util.encodeString(e)}));r=this.write(i,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}},t.prototype.refCount=function(e){return this.data.has(e)?this.data.get(e).refCount:0},t.prototype.incRef=function(e){this.data.get(e).refCount++},t.prototype.decRef=function(e){this.data.has(e)&&this.data.get(e).refCount--},t.prototype.move=function(e,a,t,n,r){this.data.set(e,{values:a,dtype:n,refCount:r})},t.prototype.numDataIds=function(){return this.data.numDataIds()},t.prototype.read=function(e){return r(this,void 0,void 0,(function(){return i(this,(function(a){return[2,this.readSync(e)]}))}))},t.prototype.readSync=function(e){var t=this.data.get(e),n=t.dtype,r=t.complexTensorInfos;if("complex64"===n){var i=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return a.backend_util.mergeRealAndImagArrays(i,s)}return this.data.get(e).values},t.prototype.bufferSync=function(e){var t=this.readSync(e.dataId),n=t;if("string"===e.dtype)try{n=t.map((function(e){return a.util.decodeString(e)}))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return a.buffer(e.shape,e.dtype,n)},t.prototype.makeOutput=function(e,t,n){var r=this.write(e,t,n);return a.engine().makeTensorFromDataId(r,t,n,this)},t.prototype.disposeData=function(e,a){if(void 0===a&&(a=!1),this.data.has(e)){if(this.data.get(e).refCount--,!a&&this.data.get(e).refCount>0)return!1;var t=this.data.get(e).complexTensorInfos;null!=t&&(this.disposeData(t.real.dataId,!0),this.disposeData(t.imag.dataId,!0)),this.data.delete(e)}return!0},t.prototype.disposeIntermediateTensorInfo=function(e){this.disposeData(e.dataId)},t.prototype.time=function(e){return r(this,void 0,void 0,(function(){var t;return i(this,(function(n){return t=a.util.now(),e(),[2,{kernelMs:a.util.now()-t}]}))}))},t.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},t.prototype.where=function(e){s([e],"where");var a=this.readSync(e.dataId);return o(e.shape,a)},t.prototype.dispose=function(){},t.prototype.floatPrecision=function(){return 32},t.prototype.epsilon=function(){return e.prototype.epsilon.call(this)},t.nextDataId=0,t}(a.KernelBackend);function d(e){for(var a=new Float32Array(e.length),t=0;t<e.length;++t)a[t]=Math.abs(e[t]);return a}var p={kernelName:a.Abs,backendName:"cpu",kernelFunc:function(e){var t=e.inputs.x,n=e.backend;s(t,"abs");var r=new Float32Array(a.util.sizeFromShape(t.shape));return r=d(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,"float32")}};function l(e){return function(t,n,r,i,s){var o=a.backend_util.assertAndGetBroadcastShape(t,n),u=o.length,d=a.util.computeStrides(o),p=a.util.sizeFromShape(o),l=a.util.getTypedArrayFromDType(s,p),c=t.length,f=n.length,h=a.util.computeStrides(t),m=a.util.computeStrides(n),v=a.backend_util.getBroadcastDims(t,o),k=a.backend_util.getBroadcastDims(n,o);if(v.length+k.length===0)for(var b=0;b<l.length;++b)l[b]=e(r[b%r.length],i[b%i.length]);else{var g=function(t){var n=a.util.indexToLoc(t,u,d),s=n.slice(-c);v.forEach((function(e){return s[e]=0}));var o=a.util.locToIndex(s,c,h),p=n.slice(-f);k.forEach((function(e){return p[e]=0}));var b=a.util.locToIndex(p,f,m);l[t]=e(r[o],i[b])};for(b=0;b<l.length;++b)g(b)}return[l,o]}}function c(e){var a=e.inputs,t=e.backend,n=a.real,r=a.imag,i=t.data.get(n.dataId).values,s=t.data.get(r.dataId).values,o=t.makeTensorInfo(n.shape,"complex64");return t.data.get(o.dataId).complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",s)},o}var f={kernelName:a.Complex,backendName:"cpu",kernelFunc:c};function h(e,t,n){if(void 0===n&&(n="float32"),"complex64"===n)return c({inputs:{real:h(e,t,"float32"),imag:h(e,t,"float32")},backend:e});var r=a.util.makeZerosTypedArray(a.util.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function m(e){var a=e.inputs,t=e.backend,n=a.x;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var v={kernelName:a.Identity,backendName:"cpu",kernelFunc:m};function k(e){var a=e.inputs,t=e.backend,n=a.input,r=t.data.get(n.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}var b={kernelName:a.Real,backendName:"cpu",kernelFunc:k};function g(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,s=r.dtype;if("complex64"===s){if("complex64"===i.dtype)return m({inputs:{x:i},backend:n});var o=h(n,i.shape,i.dtype),u=g({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),d=c({inputs:{real:u,imag:o},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),d}if("complex64"===i.dtype){var p=k({inputs:{input:i},backend:n}),d=g({inputs:{x:p},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(p),d}if(!a.util.hasEncodingLoss(i.dtype,s))return{dataId:(d=m({inputs:{x:i},backend:n})).dataId,shape:d.shape,dtype:s};if("int32"===s){var f=n.data.get(i.dataId).values,v=Int32Array.from(f);return n.makeTensorInfo(i.shape,"int32",v)}if("bool"===s){var b=n.data.get(i.dataId).values,I=a.util.toTypedArray([0],i.dtype),y=l((function(e,a){return e!==a?1:0}))(i.shape,[],b,I,"bool"),N=y[0],x=y[1];return n.makeTensorInfo(x,"bool",N)}throw new Error("Error in Cast: failed to cast "+i.dtype+" to "+s)}var I={kernelName:a.Cast,backendName:"cpu",kernelFunc:g};function y(e,a,t,n){return null==t?function(t){var r=t.inputs,i=t.backend,o=r,u=o.a,d=o.b,p=i;s([u,d],e);var l=p.data.get(u.dataId).values,c=p.data.get(d.dataId).values,f=n||u.dtype,h=a(u.shape,d.shape,l,c,f),m=h[0],v=h[1];return p.makeTensorInfo(v,f,m)}:function(e){var r=e.inputs,i=e.backend,s=r,o=s.a,u=s.b,d=i;if("complex64"===o.dtype||"complex64"===u.dtype){var p=g({inputs:{x:o},backend:d,attrs:{dtype:"complex64"}}),l=d.data.get(p.dataId),f=l.complexTensorInfos.real,h=l.complexTensorInfos.imag,m=d.data.get(f.dataId).values,v=d.data.get(h.dataId).values,k=g({inputs:{x:u},backend:d,attrs:{dtype:"complex64"}}),b=d.data.get(k.dataId),I=b.complexTensorInfos.real,y=b.complexTensorInfos.imag,N=d.data.get(I.dataId).values,x=d.data.get(y.dataId).values,T=t(o.shape,u.shape,m,v,N,x),S=T[0],F=T[1],M=T[2],A=d.makeTensorInfo(M,"float32",S),D=d.makeTensorInfo(M,"float32",F),_=c({inputs:{real:A,imag:D},backend:d});return d.disposeIntermediateTensorInfo(p),d.disposeIntermediateTensorInfo(k),d.disposeIntermediateTensorInfo(A),d.disposeIntermediateTensorInfo(D),_}var w=d.data.get(o.dataId).values,z=d.data.get(u.dataId).values,C=n||o.dtype,W=a(o.shape,u.shape,w,z,C),E=W[0];M=W[1];return d.makeTensorInfo(M,C,E)}}function N(e){return function(t,n,r,i,s,o){var u=a.backend_util.assertAndGetBroadcastShape(t,n),d=a.util.sizeFromShape(u),p=u.length,l=a.util.computeStrides(u),c=a.util.getTypedArrayFromDType("float32",d),f=a.util.getTypedArrayFromDType("float32",d),h=a.backend_util.getBroadcastDims(t,u),m=a.backend_util.getBroadcastDims(n,u),v=a.backend_util.mergeRealAndImagArrays(r,i),k=a.backend_util.mergeRealAndImagArrays(s,o),b=t.length,g=a.util.computeStrides(t),I=n.length,y=a.util.computeStrides(n);if(h.length+m.length===0)for(var N=0;N<c.length;N++){var x=N%v.length,T=N%k.length,S=e(v[2*x],v[2*x+1],k[2*T],k[2*T+1]);c[N]=S.real,f[N]=S.imag}else{var F=function(t){var n=a.util.indexToLoc(t,p,l),r=n.slice(-b);h.forEach((function(e){return r[e]=0}));var i=a.util.locToIndex(r,b,g),s=n.slice(-I);m.forEach((function(e){return s[e]=0}));var o=a.util.locToIndex(s,I,y),u=e(v[2*i],v[2*i+1],k[2*o],k[2*o+1]);c[t]=u.real,f[t]=u.imag};for(N=0;N<c.length;N++)F(N)}return[c,f,u]}}var x=l((function(e,a){return e+a})),T=N((function(e,a,t,n){return{real:e+t,imag:a+n}})),S=y(a.Add,x,T),F={kernelName:a.Add,backendName:"cpu",kernelFunc:S};function M(e,t,n,r,i){for(var s=a.util.sizeFromShape(r),o=a.util.makeZerosTypedArray(i,n),u=0;u<e.length;u++){var d=e[u];if(d<0)throw new Error("Input x must be non-negative!");d>=i||(o[d]+=s>0?t[u]:1)}return o}function A(e,t,n,r){void 0===r&&(r=!1);for(var i=e.shape[0],s=e.shape[1],o=a.buffer([i,n],t.dtype),u=0;u<i;u++)for(var d=0;d<s;d++){var p=e.get(u,d);if(p<0)throw new Error("Input x must be non-negative!");p>=n||(r?o.set(1,u,p):t.size>0?o.set(o.get(u,p)+t.get(u,d),u,p):o.set(o.get(u,p)+1,u,p))}return o}function D(e){return function(t,n,r){for(var i=a.util.getTypedArrayFromDType(n,t.length),s=0;s<t.length;++s)i[s]=e(t[s],r);return i}}function _(e,t,n){return function(r){var i=r.inputs,o=r.attrs,u=r.backend,d=i.x;if(s(d,e),"string"===d.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");for(var p=u,l=p.data.get(d.dataId).values,c=a.util.sizeFromShape(d.shape),f=n||d.dtype,h=a.util.getArrayFromDType(f,c),m=0;m<c;++m)h[m]=t(l[m],o);return p.makeTensorInfo(d.shape,f,h)}}function w(e,a,t){return function(n){var r=n.inputs,i=n.attrs,o=n.backend,u=r.x;if(s(u,e),"string"===u.dtype||"string"===t)throw new Error("unaryKernelFunc does not support string input/output");var d=o,p=d.data.get(u.dataId).values,l=t||u.dtype,c=a(p,l,i);return d.makeTensorInfo(u.shape,l,c)}}var z=D((function(e){return Math.ceil(e)})),C=w(a.Ceil,z),W={kernelName:a.Ceil,backendName:"cpu",kernelFunc:C};function E(e,t,n,r){var i=a.util.getArrayFromDType(n,a.util.sizeFromShape(t));if(r&&"string"!==n){var s=0;e.forEach((function(e){var t=a.util.sizeFromShape(e.shape);i.set(e.vals,s),s+=t}))}else{var o=0;e.forEach((function(e){for(var r="string"===n?a.backend_util.fromUint8ToStringArray(e.vals):e.vals,s=0,u=0;u<e.shape[0];++u)for(var d=u*t[1]+o,p=0;p<e.shape[1];++p)i[d+p]=r[s++];o+=e.shape[1]}))}return i}var H=D((function(e){return Math.exp(e)})),P=w(a.Exp,H),R={kernelName:a.Exp,backendName:"cpu",kernelFunc:P},B=D((function(e){return Math.expm1(e)})),O=w(a.Expm1,B),L={kernelName:a.Expm1,backendName:"cpu",kernelFunc:O},V=D((function(e){return Math.floor(e)})),q=w(a.Floor,V),G={kernelName:a.Floor,backendName:"cpu",kernelFunc:q};function U(e,t,n){for(var r=a.buffer(n,e.dtype),i=0;i<r.size;++i){var s=r.indexToLoc(i).slice(),o=s[0],u=s[2],d=t.locToIndex([o,u]);s[2]=t.values[d];var p=e.locToIndex(s);r.values[i]=e.values[p]}return r}var Z=l((function(e,a){return e>a?1:0})),j=y(a.Greater,Z,null,"bool"),K={kernelName:a.Greater,backendName:"cpu",kernelFunc:j},Y=l((function(e,a){return e<a?1:0})),$=y(a.Less,Y,null,"bool"),J={kernelName:a.Less,backendName:"cpu",kernelFunc:$};function Q(e,t,n){var r=(t-e)/(n-1),i=a.util.makeZerosTypedArray(n,"float32");i[0]=e;for(var s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}var X=D((function(e){return Math.log(e)})),ee=w(a.Log,X),ae={kernelName:a.Log,backendName:"cpu",kernelFunc:ee};function te(e,t,n,r){for(var i=a.util.getTypedArrayFromDType(r,a.util.sizeFromShape(n)),s=0;s<i.length;++s){for(var o=s*t,u=e[o],d=0;d<t;++d){var p=e[o+d];p>u&&(u=p)}i[s]=u}return i}var ne=l((function(e,a){return Math.max(e,a)})),re=y(a.Maximum,ne),ie={kernelName:a.Maximum,backendName:"cpu",kernelFunc:re},se=l((function(e,a){return Math.min(e,a)})),oe=y(a.Minimum,se),ue={kernelName:a.Minimum,backendName:"cpu",kernelFunc:oe},de=l((function(e,a){return e*a})),pe=N((function(e,a,t,n){return{real:e*t-a*n,imag:e*n+a*t}})),le=y(a.Multiply,de,pe),ce={kernelName:a.Multiply,backendName:"cpu",kernelFunc:le};function fe(e,t,n){var r=a.util.createScalarValue(-1,n);return de([],t,r,e,n)}var he={kernelName:a.Neg,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=a.x;s(n,"neg");var r=fe(t.data.get(n.dataId).values,n.shape,n.dtype),i=r[0],o=r[1];return t.makeTensorInfo(o,n.dtype,i)}},me=l((function(e,a){return e!==a?1:0})),ve=y(a.NotEqual,me,null,"bool"),ke={kernelName:a.NotEqual,backendName:"cpu",kernelFunc:ve};function be(e,t,n,r,i){for(var s=t.length,o=a.util.sizeFromShape(t),u=a.util.computeStrides(t),d=a.util.computeStrides(i),p=a.util.getTypedArrayFromDType(n,a.util.sizeFromShape(i)),l=0;l<o;++l){for(var c=a.util.indexToLoc(l,s,u),f=new Array(c.length),h=0;h<f.length;h++)f[h]=c[r[h]];p[a.util.locToIndex(f,s,d)]=e[l]}return p}function ge(e){var a=e.inputs,t=e.attrs,n=e.backend,r=a.x,i=t.perm;s(r,"transpose");for(var o=r.shape.length,u=new Array(o),d=0;d<u.length;d++)u[d]=r.shape[i[d]];var p=be(n.data.get(r.dataId).values,r.shape,r.dtype,i,u);return{dataId:n.write(p,u,r.dtype),shape:u,dtype:r.dtype}}var Ie={kernelName:a.Transpose,backendName:"cpu",kernelFunc:ge};function ye(e,t,n,r){for(var i=a.backend_util.computeOutAndReduceShapes(e,r),s=i[0],o=i[1],u=a.upcastType(t,"int32"),d=a.util.makeZerosTypedArray(a.util.sizeFromShape(s),u),p=a.util.sizeFromShape(o),l=0;l<d.length;++l){for(var c=l*p,f=1,h=0;h<p;++h)f*=n[c+h];d[l]=f}return{outVals:d,outShape:s,outDtype:u}}var Ne={kernelName:a.Prod,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,u=r.keepDims;s(i,"prod");var d=i.shape.length,p=a.util.parseAxisParam(o,i.shape),l=a.backend_util.getAxesPermutation(p,d),c=p,f=i,h=[];null!=l&&(f=ge({inputs:{x:i},backend:n,attrs:{perm:l}}),h.push(f),c=a.backend_util.getInnerMostAxes(c.length,d));var m=n.data.get(f.dataId).values,v=ye(f.shape,f.dtype,m,c),k=v.outVals,b=v.outShape,g=v.outDtype,I=b;return u&&(I=a.backend_util.expandShapeToKeepDim(b,p)),h.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),n.makeTensorInfo(I,g,k)}};function xe(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return a.util.makeZerosTypedArray(0,r);var i=Math.abs(Math.ceil((t-e)/n)),s=a.util.makeZerosTypedArray(i,r);t<e&&1===n&&(n=-1),s[0]=e;for(var o=1;o<s.length;o++)s[o]=s[o-1]+n;return s}var Te=D((function(e){return 1/Math.sqrt(e)})),Se=w(a.Rsqrt,Te),Fe={kernelName:a.Rsqrt,backendName:"cpu",kernelFunc:Se};function Me(e,t,n,r,i){var s=a.slice_util.isSliceContinous(r,t,n),o=a.util.sizeFromShape(n),u=a.util.computeStrides(r);if(s){var d=a.slice_util.computeFlatOffset(t,u);return"string"===i?e.slice(d,d+o):e.subarray(d,d+o)}for(var p="string"===i?a.backend_util.fromUint8ToStringArray(e):e,l=a.buffer(r,i,p),c=a.buffer(n,i),f=0;f<c.size;++f){var h=c.indexToLoc(f),m=h.map((function(e,a){return e+t[a]}));c.set.apply(c,[l.get.apply(l,m)].concat(h))}return"string"===i?a.backend_util.fromStringArrayToUint8(c.values):c.values}function Ae(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.begin,u=r.size;s(i,"slice");var d=a.slice_util.parseSliceParams(i,o,u),p=d[0],l=d[1];a.slice_util.assertParamsValid(i,p,l);var c=Me(n.data.get(i.dataId).values,p,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,c)}var De={kernelName:a.Slice,backendName:"cpu",kernelFunc:Ae},_e=l((function(e,a){var t=e-a;return t*t})),we=y(a.SquaredDifference,_e),ze={kernelName:a.SquaredDifference,backendName:"cpu",kernelFunc:we};function Ce(e,t,n,r){for(var i=a.buffer(e,t.dtype),s=0;s<i.size;s++){for(var o=i.indexToLoc(s),u=new Array(o.length),d=0;d<u.length;d++)u[d]=o[d]*n[d]+r[d];i.set.apply(i,[t.get.apply(t,u)].concat(o))}return i}var We=l((function(e,a){return e-a})),Ee=N((function(e,a,t,n){return{real:e-t,imag:a-n}})),He=y(a.Sub,We,Ee),Pe={kernelName:a.Sub,backendName:"cpu",kernelFunc:He};function Re(e,t){for(var n=new Array(e.rank),r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];var i=a.buffer(n,e.dtype);for(r=0;r<i.values.length;++r){for(var s=i.indexToLoc(r),o=new Array(e.rank),u=0;u<o.length;u++)o[u]=s[u]%e.shape[u];var d=e.locToIndex(o);i.values[r]=e.values[d]}return i}function Be(e,t,n,r,i){for(var s=t[t.length-1],o=[e.length/s,s],u=o[0],d=o[1],p=a.util.getTypedArrayFromDType(n,u*r),l=a.util.getTypedArrayFromDType("int32",u*r),c=0;c<u;c++){for(var f=c*d,h=e.subarray(f,f+d),m=[],v=0;v<h.length;v++)m.push({value:h[v],index:v});m.sort((function(e,a){return a.value-e.value}));var k=c*r,b=p.subarray(k,k+r),g=l.subarray(k,k+r);for(v=0;v<r;v++)b[v]=m[v].value,g[v]=m[v].index}var I=t.slice();return I[I.length-1]=r,[a.buffer(I,n,p),a.buffer(I,"int32",l)]}function Oe(e,t,n,r){for(var i=a.util.parseAxisParam(t,n)[0],s=[1,n[0],1],o=0;o<i;o++)s[0]*=n[o];s[1]=n[i];for(o=i+1;o<n.length;o++)s[2]*=n[o];var u={},d=new Int32Array(n[i]),p=new a.TensorBuffer(s,r,e),l=[],c=1===s[0]&&1===s[2];for(o=0;o<n[i];o++){var f=void 0;if(c)f=e[o].toString();else{for(var h=[],m=0;m<s[0];m++)for(var v=0;v<s[2];v++)h.push(p.get(m,o,v));f=h.join(",")}if(void 0!==u[f])d[o]=u[f];else{var k=Object.keys(u).length;u[f]=k,d[o]=k,l.push(o)}}var b=s.slice();b[1]=Object.keys(u).length;var g=new a.TensorBuffer(b,r);l.forEach((function(e,a){for(var t=0;t<s[0];t++)for(var n=0;n<s[2];n++)g.set(p.get(t,e,n),t,a,n)}));var I=n.slice();return I[i]=b[1],{outputValues:g.values,outputShape:I,indices:d}}var Le={__proto__:null,simpleAbsImpl:d,addImpl:x,bincountImpl:M,bincountReduceImpl:A,ceilImpl:z,concatImpl:E,expImpl:H,expm1Impl:B,floorImpl:V,gatherV2Impl:U,greaterImpl:Z,lessImpl:Y,linSpaceImpl:Q,logImpl:X,maxImpl:te,maximumImpl:ne,minimumImpl:se,multiplyImpl:de,negImpl:fe,notEqualImpl:me,prodImpl:ye,rangeImpl:xe,rsqrtImpl:Te,sliceImpl:Me,squaredDifferenceImpl:_e,stridedSliceImpl:Ce,subImpl:We,tileImpl:Re,topKImpl:Be,transposeImpl:be,uniqueImpl:Oe};a.registerBackend("cpu",(function(){return new u}),1);var Ve=_(a.Elu,(function(e){return e>=0?e:Math.exp(e)-1})),qe={kernelName:a.Elu,backendName:"cpu",kernelFunc:Ve};function Ge(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.alpha;s([i],"leakyRelu");for(var u=a.util.sizeFromShape(i.shape),d=n.data.get(i.dataId).values,p=a.util.getTypedArrayFromDType("float32",u),l=0;l<d.length;l++)p[l]=d[l]<0?o*d[l]:d[l];return n.makeTensorInfo(i.shape,"float32",p)}var Ue={kernelName:a.LeakyRelu,backendName:"cpu",kernelFunc:Ge},Ze=l((function(e,a){return e<0?a*e:e}));function je(e){var a=e.inputs,t=e.backend,n=a.x,r=a.alpha;s([n,r],"prelu");var i=t.data.get(n.dataId).values,o=t.data.get(r.dataId).values,u=Ze(n.shape,r.shape,i,o,n.dtype),d=u[0],p=u[1];return t.makeTensorInfo(p,n.dtype,d)}var Ke={kernelName:a.Prelu,backendName:"cpu",kernelFunc:je},Ye=_(a.Relu,(function(e){return Math.max(0,e)})),$e={kernelName:a.Relu,backendName:"cpu",kernelFunc:Ye},Je=_(a.Relu6,(function(e){return Math.min(Math.max(0,e),6)})),Qe={kernelName:a.Relu6,backendName:"cpu",kernelFunc:Je};function Xe(e,a,t,n,r){if("linear"===t)return m({inputs:{x:a},backend:e});if("relu"===t)return Ye({inputs:{x:a},backend:e});if("elu"===t)return Ve({inputs:{x:a},backend:e});if("relu6"===t)return Je({inputs:{x:a},backend:e});if("prelu"===t)return je({inputs:{x:a,alpha:n},backend:e});if("leakyrelu"===t)return Ge({inputs:{x:a},backend:e,attrs:{alpha:r}});throw new Error("Activation "+t+" has not been implemented for the CPU backend.")}function ea(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,s=r.shape,o=a.util.sizeFromShape(i.shape),u=a.util.inferFromImplicitShape(s,o),d=a.util.sizeFromShape(u);a.util.assert(o===d,(function(){return"The new shape ("+u+") has "+d+" elements and the old shape ("+i.shape+") has "+o+" elements. The new shape and old shape must have the same number of elements."})),n.incRef(i.dataId);var p=n.data.get(i.dataId);if(null!=p.complexTensorInfos){var l=p.complexTensorInfos.real,c=p.complexTensorInfos.imag;l.shape=u,c.shape=u}return{dataId:i.dataId,shape:u,dtype:i.dtype}}var aa={kernelName:a.Reshape,backendName:"cpu",kernelFunc:ea};function ta(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.a,o=t.b,u=r.transposeA,d=r.transposeB;s([i,o],"matMul");var p=i.shape.length,l=o.shape.length,c=u?i.shape[p-2]:i.shape[p-1],f=d?o.shape[l-1]:o.shape[l-2],h=u?i.shape[p-1]:i.shape[p-2],m=d?o.shape[l-2]:o.shape[l-1],v=i.shape.slice(0,-2),k=o.shape.slice(0,-2),b=a.util.sizeFromShape(v),g=a.util.sizeFromShape(k),I=b===g||1===b||1===g;a.util.assert(p>=2&&l>=2&&I,(function(){return"Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of ("+v+") and ("+k+")."}));var y=(b>g?i.shape.slice(0,-2):o.shape.slice(0,-2)).concat([h,m]);a.util.assert(c===f,(function(){return"Error in matMul: inner shapes ("+c+") and ("+f+") of Tensors with shapes "+i.shape+" and "+o.shape+" and transposeA="+u+" and transposeB="+d+" must match."}));for(var N=d?[g,m,f]:[g,f,m],x=ea({inputs:{x:i},backend:n,attrs:{shape:u?[b,c,h]:[b,h,c]}}),T=ea({inputs:{x:o},backend:n,attrs:{shape:N}}),S=u?x.shape[1]:x.shape[2],F=u?x.shape[2]:x.shape[1],M=d?T.shape[1]:T.shape[2],A=Math.max(b,g),D=n.data.get(x.dataId).values,_=n.data.get(T.dataId).values,w=a.util.computeStrides(x.shape),z=a.util.computeStrides(T.shape),C=u?[w[0],1,w[1]]:[w[0],w[1],1],W=C[0],E=C[1],H=C[2],P=d?[1,z[1],z[0]]:[z[1],1,z[0]],R=P[0],B=P[1],O=P[2],L=F*M,V=a.buffer([A,F,M],x.dtype),q=V.values,G=n.blockSize,U=0;U<A;U++)for(var Z=0;Z<F;Z+=G)for(var j=0;j<M;j+=G)for(var K=0;K<S;K+=G)for(var Y=Math.min(Z+G,F),$=Math.min(j+G,M),J=Math.min(K+G,S),Q=Z;Q<Y;Q++)for(var X=j;X<$;X++){for(var ee=0,ae=K;ae<J;ae++){var te=Math.min(U,b-1)*W,ne=Math.min(U,g-1)*O;ee+=D[te+Q*E+ae*H]*_[ae*R+X*B+ne]}q[U*L+(Q*M+X)]+=ee}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(T),n.makeTensorInfo(y,V.dtype,V.values)}var na={kernelName:a.BatchMatMul,backendName:"cpu",kernelFunc:ta};var ra={kernelName:a._FusedMatMul,backendName:"cpu",kernelFunc:function(e){var a,t,n,r=e.inputs,i=e.backend,s=e.attrs,o=r.a,u=r.b,d=r.bias,p=r.preluActivationWeights,l=s.transposeA,c=s.transposeB,f=s.activation,h=s.leakyreluAlpha,m=[];a=ta({inputs:{a:o,b:u},attrs:{transposeA:l,transposeB:c},backend:i}),d&&(t=S({inputs:{a:a,b:d},backend:i}),m.push(a),a=t),f&&(n=Xe(i,a,f,p,h),m.push(a),a=n);for(var v=0,k=m;v<k.length;v++){var b=k[v];i.disposeIntermediateTensorInfo(b)}return a}},ia=_(a.Acos,(function(e){return Math.acos(e)})),sa={kernelName:a.Acos,backendName:"cpu",kernelFunc:ia},oa=_(a.Acosh,(function(e){return Math.acosh(e)})),ua={kernelName:a.Acosh,backendName:"cpu",kernelFunc:oa};var da={kernelName:a.AddN,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t;s(t,"addN");for(var i=r.map((function(e){return n.data.get(e.dataId).values})),o=a.buffer(r[0].shape,r[0].dtype),u=o.values,d=0;d<r.length;d++)for(var p=i[d],l=0;l<u.length;l++)u[l]+=p[l];return n.makeTensorInfo(o.shape,o.dtype,o.values)}};var pa={kernelName:a.All,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,u=r.keepDims;s(i,"all");var d=a.util.parseAxisParam(o,i.shape),p=d,l=a.backend_util.getAxesPermutation(p,i.shape.length),c=i;null!=l&&(c=ge({inputs:{x:i},backend:n,attrs:{perm:l}}),p=a.backend_util.getInnerMostAxes(p.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("all",p,c.shape.length);for(var f=a.backend_util.computeOutAndReduceShapes(c.shape,p),h=f[0],m=f[1],v=a.util.sizeFromShape(m),k=a.util.makeZerosTypedArray(a.util.sizeFromShape(h),c.dtype),b=n.data.get(c.dataId).values,g=0;g<k.length;++g){for(var I=g*v,y=b[I],N=0;N<v;++N){var x=b[I+N];y=y&&x}k[g]=y}null!=l&&n.disposeIntermediateTensorInfo(c);var T=n.makeTensorInfo(h,c.dtype,k);if(u){var S=ea({inputs:{x:T},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(h,d)}});return n.disposeIntermediateTensorInfo(T),S}return T}};var la={kernelName:a.Any,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,u=r.keepDims;s(i,"any");var d=a.util.parseAxisParam(o,i.shape),p=d,l=a.backend_util.getAxesPermutation(p,i.shape.length),c=i;null!=l&&(c=ge({inputs:{x:i},backend:n,attrs:{perm:l}}),p=a.backend_util.getInnerMostAxes(p.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("any",p,c.shape.length);for(var f=a.backend_util.computeOutAndReduceShapes(c.shape,p),h=f[0],m=f[1],v=a.util.sizeFromShape(m),k=a.util.makeZerosTypedArray(a.util.sizeFromShape(h),c.dtype),b=n.data.get(c.dataId).values,g=0;g<k.length;++g){for(var I=g*v,y=b[I],N=0;N<v;++N){var x=b[I+N];y=y||x}k[g]=y}null!=l&&n.disposeIntermediateTensorInfo(c);var T=n.makeTensorInfo(h,c.dtype,k);if(u){var S=ea({inputs:{x:T},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(h,d)}});return n.disposeIntermediateTensorInfo(T),S}return T}};var ca={kernelName:a.ArgMax,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis;s(i,"argMax");var u=a.util.parseAxisParam(o,i.shape),d=a.backend_util.getAxesPermutation(u,i.shape.length),p=i,l=[];null!=d&&(p=ge({inputs:{x:i},backend:n,attrs:{perm:d}}),l.push(p),u=a.backend_util.getInnerMostAxes(u.length,p.shape.length)),u=[u[0]],a.backend_util.assertAxesAreInnerMostDims("argMax",u,p.shape.length);for(var c=a.backend_util.computeOutAndReduceShapes(p.shape,u),f=c[0],h=c[1],m=a.util.sizeFromShape(f),v=a.util.makeZerosTypedArray(m,"int32"),k=a.util.sizeFromShape(h),b=n.data.get(p.dataId).values,g=0;g<v.length;++g){for(var I=g*k,y=b[I],N=0,x=0;x<k;++x){var T=b[I+x];T>y&&(y=T,N=x)}v[g]=N}return l.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),n.makeTensorInfo(f,"int32",v)}};var fa={kernelName:a.ArgMin,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis;s(i,"argMin");var u=a.util.parseAxisParam(o,i.shape),d=a.backend_util.getAxesPermutation(u,i.shape.length),p=i,l=[];null!=d&&(p=ge({inputs:{x:i},backend:n,attrs:{perm:d}}),l.push(p),u=a.backend_util.getInnerMostAxes(u.length,p.shape.length)),u=[u[0]],a.backend_util.assertAxesAreInnerMostDims("argMin",u,p.shape.length);for(var c=a.backend_util.computeOutAndReduceShapes(p.shape,u),f=c[0],h=c[1],m=a.util.sizeFromShape(f),v=a.util.makeZerosTypedArray(m,"int32"),k=a.util.sizeFromShape(h),b=n.data.get(p.dataId).values,g=0;g<v.length;++g){for(var I=g*k,y=b[I],N=0,x=0;x<k;++x){var T=b[I+x];T<y&&(y=T,N=x)}v[g]=N}return l.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),n.makeTensorInfo(f,"int32",v)}},ha=_(a.Asin,(function(e){return Math.asin(e)})),ma={kernelName:a.Asin,backendName:"cpu",kernelFunc:ha},va=_(a.Asinh,(function(e){return Math.asinh(e)})),ka={kernelName:a.Asinh,backendName:"cpu",kernelFunc:va},ba=_(a.Atan,(function(e){return Math.atan(e)})),ga={kernelName:a.Atan,backendName:"cpu",kernelFunc:ba},Ia=l((function(e,a){return Math.atan2(e,a)})),ya=y(a.Atan2,Ia),Na={kernelName:a.Atan2,backendName:"cpu",kernelFunc:ya},xa=_(a.Atanh,(function(e){return Math.atanh(e)})),Ta={kernelName:a.Atanh,backendName:"cpu",kernelFunc:xa};function Sa(e,t,n,r,i,s){for(var o=i.strideHeight,u=i.strideWidth,d=i.dilationHeight,p=i.dilationWidth,l=i.effectiveFilterHeight,c=i.effectiveFilterWidth,f=i.padInfo.top,h=i.padInfo.left,m="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=a.buffer(i.outShape,n),k=v.values,b=i.outShape[1]*i.outShape[2]*i.outShape[3],g=i.outShape[2]*i.outShape[3],I=i.outShape[3],y=0;y<i.batchSize;++y)for(var N=y*b,x=y*r[0],T=0;T<i.inChannels;++T)for(var S=0;S<i.outHeight;++S)for(var F=S*o-f,M=Math.max(0,F),A=Math.min(i.inHeight,l+F),D=N+S*g,_=0;_<i.outWidth;++_){for(var w=_*u-h,z=Math.max(0,w),C=Math.min(i.inWidth,c+w),W=m,E=0,H=0,P=M;P<A;P+=d){for(var R=x+P*r[1],B=z;B<C;B+=p){var O=e[R+B*r[2]+T];"max"===s&&O>W?W=O:"avg"===s&&(E+=O,H++)}if(isNaN(W))break}k[D+_*I+T]="avg"===s?E/H:W}return v}function Fa(e,t,n,r,i,s){void 0===i&&(i=!1),void 0===s&&(s=!1);for(var o=a.buffer(r.outShape,"int32"),u=r.strideHeight,d=r.strideWidth,p=r.dilationHeight,l=r.dilationWidth,c=r.effectiveFilterHeight,f=r.effectiveFilterWidth,h=r.padInfo.top,m=r.padInfo.left,v=a.buffer(t,n,e),k=0;k<r.batchSize;++k)for(var b=0;b<r.inChannels;++b)for(var g=0;g<r.outHeight;++g){for(var I=g*u-h,y=I;y<0;)y+=p;for(var N=Math.min(r.inHeight,c+I),x=0;x<r.outWidth;++x){for(var T=x*d-m,S=T;S<0;)S+=l;for(var F=Math.min(r.inWidth,f+T),M=Number.NEGATIVE_INFINITY,A=-1,D=y;D<N;D+=p)for(var _=D-I,w=S;w<F;w+=l){var z=w-T,C=v.get(k,D,w,b);C>M&&(M=C,A=i?s?((k*r.inHeight+D)*r.inWidth+w)*r.inChannels+b:(D*r.inWidth+w)*r.inChannels+b:_*f+z)}o.set(A,k,g,x,b)}}return o}function Ma(e,t,n,r,i,s){for(var o=i.strideDepth,u=i.strideHeight,d=i.strideWidth,p=i.dilationDepth,l=i.dilationHeight,c=i.dilationWidth,f=i.effectiveFilterDepth,h=i.effectiveFilterHeight,m=i.effectiveFilterWidth,v=i.padInfo.front,k=i.padInfo.top,b=i.padInfo.left,g="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=a.buffer(i.outShape,n),y=I.values,N=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],x=i.outShape[2]*i.outShape[3]*i.outShape[4],T=i.outShape[3]*i.outShape[4],S=i.outShape[4],F=0;F<i.batchSize;++F)for(var M=F*N,A=F*r[0],D=0;D<i.inChannels;++D)for(var _=0;_<i.outDepth;++_){for(var w=_*o-v,z=w;z<0;)z+=p;for(var C=Math.min(i.inDepth,f+w),W=M+_*x,E=0;E<i.outHeight;++E){for(var H=E*u-k,P=H;P<0;)P+=l;for(var R=Math.min(i.inHeight,h+H),B=W+E*T,O=0;O<i.outWidth;++O){for(var L=O*d-b,V=L;V<0;)V+=c;for(var q=Math.min(i.inWidth,m+L),G=B+O*S,U=g,Z=0,j=0,K=z;K<C;K+=p){for(var Y=A+K*r[1],$=P;$<R;$+=l){for(var J=Y+$*r[2],Q=V;Q<q;Q+=c){var X=e[J+Q*r[3]+D];if("max"===s&&X>U?U=X:"avg"===s&&(Z+=X,j++),isNaN(U))break}if(isNaN(U))break}if(isNaN(U))break}y[G+D]="avg"===s?Z/j:U}}}return I}var Aa={kernelName:a.AvgPool,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x;s(i,"avgPool");var o=r.filterSize,u=r.strides,d=r.pad,p=r.dimRoundingMode;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(u,1),(function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+u+" and dilations '1'"}));var l,c=a.backend_util.computePool2DInfo(i.shape,o,u,1,d,p);if(1===c.filterWidth&&1===c.filterHeight&&a.util.arraysEqual(c.inShape,c.outShape))l=m({inputs:{x:i},backend:n});else{var f=n.data.get(i.dataId).values,h=a.util.computeStrides(i.shape),v=Sa(f,i.shape,i.dtype,h,c,"avg");l=n.makeTensorInfo(c.outShape,i.dtype,v.values)}return l}};var Da={kernelName:a.AvgPool3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.filterSize,u=r.strides,d=r.pad,p=r.dimRoundingMode,l=r.dataFormat;s(i,"avgPool3d");var c=a.backend_util.computePool3DInfo(i.shape,o,u,1,d,p,l),f=Ma(n.data.get(i.dataId).values,i.shape,i.dtype,a.util.computeStrides(i.shape),c,"avg");return n.makeTensorInfo(f.shape,"float32",f.values)}};var _a={kernelName:a.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.input,u=r.filterSize,d=r.strides,p=r.pad,l=r.dimRoundingMode;s([i,o],"avgPool3DGrad");for(var c=a.backend_util.computePool3DInfo(o.shape,u,d,1,p,l),f=c.strideDepth,h=c.strideHeight,m=c.strideWidth,v=c.filterDepth,k=c.filterHeight,b=c.filterWidth,g=c.dilationDepth,I=c.dilationHeight,y=c.dilationWidth,N=c.effectiveFilterDepth,x=c.effectiveFilterHeight,T=c.effectiveFilterWidth,S=N-1-c.padInfo.front,F=T-1-c.padInfo.left,M=x-1-c.padInfo.top,A=a.buffer(o.shape,"float32"),D=1/(v*k*b),_=n.bufferSync(i),w=0;w<c.batchSize;++w)for(var z=0;z<c.inChannels;++z)for(var C=0;C<c.inDepth;++C)for(var W=0;W<c.inHeight;++W)for(var E=0;E<c.inWidth;++E){for(var H=C-S,P=W-M,R=E-F,B=0,O=0;O<N;O+=g){var L=(H+O)/f;if(!(L<0||L>=c.outDepth||Math.floor(L)!==L))for(var V=0;V<x;V+=I){var q=(P+V)/h;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(var G=0;G<T;G+=y){var U=(R+G)/m;if(!(U<0||U>=c.outWidth||Math.floor(U)!==U))B+=_.get(w,L,q,U,z)}}}A.set(B*D,w,C,W,E,z)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}};var wa={kernelName:a.AvgPoolGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.input,u=o;s([i,o],"avgPoolGrad");for(var d=r.filterSize,p=r.strides,l=r.pad,c=a.backend_util.computePool2DInfo(u.shape,d,p,1,l),f=c.strideHeight,h=c.strideWidth,m=c.filterHeight,v=c.filterWidth,k=c.dilationHeight,b=c.dilationWidth,g=c.effectiveFilterHeight,I=c.effectiveFilterWidth,y=I-1-c.padInfo.left,N=g-1-c.padInfo.top,x=a.buffer(u.shape,"float32"),T=1/(m*v),S=n.data.get(i.dataId).values,F=a.buffer(i.shape,"float32",S),M=0;M<c.batchSize;++M)for(var A=0;A<c.inChannels;++A)for(var D=0;D<c.inHeight;++D)for(var _=0;_<c.inWidth;++_){for(var w=D-N,z=_-y,C=0,W=0;W<g;W+=k){var E=(w+W)/f;if(!(E<0||E>=c.outHeight||Math.floor(E)!==E))for(var H=0;H<I;H+=b){var P=(z+H)/h;if(!(P<0||P>=c.outWidth||Math.floor(P)!==P))C+=F.get(M,E,P,A)}}x.set(C*T,M,D,_,A)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};var za={kernelName:a.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.scale,u=t.offset,d=t.mean,p=t.variance;a.util.assert(d.shape.length===p.shape.length,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),a.util.assert(null==u||d.shape.length===u.shape.length,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),a.util.assert(null==o||d.shape.length===o.shape.length,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."})),s([i,d,p,o,u],"batchNorm");var l=r.varianceEpsilon;null==l&&(l=.001);for(var c=n.data.get(i.dataId).values,f=n.data.get(d.dataId).values,h=n.data.get(p.dataId).values,m=o?n.data.get(o.dataId).values:new Float32Array([1]),v=u?n.data.get(u.dataId).values:new Float32Array([0]),k=new Float32Array(c.length),b=v.length,g=m.length,I=h.length,y=f.length,N=0,x=0,T=0,S=0,F=0;F<c.length;++F)k[F]=v[N++]+(c[F]-f[x++])*m[T++]/Math.sqrt(h[S++]+l),N>=b&&(N=0),x>=y&&(x=0),T>=g&&(T=0),S>=I&&(S=0);return n.makeTensorInfo(i.shape,i.dtype,k)}};var Ca={kernelName:a.BatchToSpaceND,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.blockShape,u=r.crops;s([i],"batchToSpaceND");var d=o.reduce((function(e,a){return e*a})),p=a.backend_util.getReshaped(i.shape,o,d),l=a.backend_util.getPermuted(p.length,o.length),c=a.backend_util.getReshapedPermuted(i.shape,o,d),f=a.backend_util.getSliceBeginCoords(u,o.length),h=a.backend_util.getSliceSize(c,u,o.length),m=ea({inputs:{x:i},backend:n,attrs:{shape:p}}),v=ge({inputs:{x:m},backend:n,attrs:{perm:l}}),k=ea({inputs:{x:v},backend:n,attrs:{shape:c}}),b=Ae({inputs:{x:k},backend:n,attrs:{begin:f,size:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k),b}};var Wa={kernelName:a.Bincount,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=a.weights,s=n.size,o=M(t.data.get(r.dataId).values,t.data.get(i.dataId).values,i.dtype,i.shape,s);return t.makeTensorInfo([s],i.dtype,o)}},Ea=_(a.ClipByValue,(function(e,a){var t=a;return e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e})),Ha={kernelName:a.ClipByValue,backendName:"cpu",kernelFunc:Ea},Pa={kernelName:a.ComplexAbs,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs.x,n=e.backend,r=new Float32Array(a.util.sizeFromShape(t.shape)),i=n.data.get(t.dataId),s=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,u=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,p=0;p<u.length;p++){var l=u[p],c=d[p];r[p]=Math.hypot(l,c)}return n.makeOutput(r,t.shape,"float32")}};function Ra(e){var a=e.inputs,t=e.backend,n=a.input,r=t.data.get(n.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}var Ba={kernelName:a.Imag,backendName:"cpu",kernelFunc:Ra};function Oa(e){var t=e.inputs,n=e.backend,r=e.attrs.axis,i=a.util.parseAxisParam(r,t[0].shape)[0],s=a.backend_util.computeOutShape(t.map((function(e){return e.shape})),i);if(0===a.util.sizeFromShape(s))return n.makeTensorInfo(s,t[0].dtype,[]);var o=t.filter((function(e){return a.util.sizeFromShape(e.shape)>0}));if(1===o.length)return m({inputs:{x:o[0]},backend:n});var u=o.map((function(e){return e.shape}));if(a.backend_util.assertParamsConsistent(u,i),"complex64"===o[0].dtype){var d=o.map((function(e){return k({inputs:{input:e},backend:n})})),p=o.map((function(e){return Ra({inputs:{input:e},backend:n})})),l=Oa({inputs:d,backend:n,attrs:{axis:i}}),f=Oa({inputs:p,backend:n,attrs:{axis:i}}),h=c({inputs:{real:l,imag:f},backend:n});return d.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),p.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(f),h}var v=o.map((function(e){var t=a.util.sizeFromShape(e.shape.slice(i));return ea({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),b=v.map((function(e){return{vals:n.data.get(e.dataId).values,shape:e.shape}}));s=a.backend_util.computeOutShape(v.map((function(e){return e.shape})),1);var g=1===v[0].shape[0],I=E(b,s,t[0].dtype,g),y=a.backend_util.computeOutShape(o.map((function(e){return e.shape})),i),N=n.makeTensorInfo(y,t[0].dtype,I);return v.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),N}var La={kernelName:a.Concat,backendName:"cpu",kernelFunc:Oa};function Va(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,u=r.strides,d=r.pad,p=r.dataFormat,l=r.dilations,c=r.dimRoundingMode;s([i,o],"conv2d");for(var f=a.backend_util.convertConv2DDataFormat(p),h=a.backend_util.computeConv2DInfo(i.shape,o.shape,u,l,d,c,!1,f),m=h.filterHeight,v=h.filterWidth,k=h.dilationHeight,b=h.dilationWidth,g=h.padInfo.left,I=h.padInfo.top,y="channelsLast"===h.dataFormat,N=new a.TensorBuffer(h.outShape,i.dtype),x=a.util.computeStrides(i.shape),T=a.util.computeStrides(o.shape),S=x[0],F=y?x[1]:x[2],M=y?x[2]:1,A=y?1:x[1],D=N.strides[0],_=y?N.strides[1]:N.strides[2],w=y?N.strides[2]:1,z=y?1:N.strides[1],C=n.data.get(i.dataId).values,W=n.data.get(o.dataId).values,E=N.values,H=0;H<h.batchSize;++H)for(var P=H*S,R=H*D,B=0;B<h.outHeight;++B)for(var O=R+B*_,L=B*h.strideHeight-I,V=0;V<m;++V){var q=L+V*k;if(!(q<0||q>=h.inHeight))for(var G=V*T[0],U=P+q*F,Z=0;Z<h.outWidth;++Z)for(var j=O+Z*w,K=Z*h.strideWidth-g,Y=0;Y<v;++Y){var $=K+Y*b;if(!($<0||$>=h.inWidth))for(var J=U+$*M,Q=G+Y*T[1],X=0;X<h.inChannels;++X){for(var ee=C[J+X*A],ae=0;ae<h.outChannels;++ae)E[j+ae*z]+=ee*W[Q+ae];Q+=h.outChannels}}}return n.makeTensorInfo(N.shape,N.dtype,E)}var qa={kernelName:a.Conv2D,backendName:"cpu",kernelFunc:Va};var Ga={kernelName:a.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.dy,u=r.strides,d=r.pad,p=r.dataFormat,l=r.dimRoundingMode,c=r.filterShape;s([i,o],"conv2dBackpropFilter");for(var f=a.backend_util.convertConv2DDataFormat(p),h=a.backend_util.computeConv2DInfo(i.shape,c,u,1,d,l,!1,f),m=h.strideHeight,v=h.strideWidth,k=h.filterHeight,b=h.filterWidth,g="channelsLast"===h.dataFormat,I=new a.TensorBuffer(h.filterShape,"float32"),y=h.padInfo.left,N=h.padInfo.top,x=n.data.get(i.dataId).values,T=n.data.get(o.dataId).values,S=new a.TensorBuffer(i.shape,i.dtype,x),F=new a.TensorBuffer(o.shape,o.dtype,T),M=0;M<k;++M)for(var A=Math.max(0,Math.ceil((N-M)/m)),D=Math.min(h.outHeight,(h.inHeight+N-M)/m),_=0;_<b;++_)for(var w=Math.max(0,Math.ceil((y-_)/v)),z=Math.min(h.outWidth,(h.inWidth+y-_)/v),C=0;C<h.inChannels;++C)for(var W=0;W<h.outChannels;++W){for(var E=0,H=0;H<h.batchSize;++H)for(var P=A;P<D;++P)for(var R=M+P*m-N,B=w;B<z;++B){var O=_+B*v-y;E+=g?S.get(H,R,O,C)*F.get(H,P,B,W):S.get(H,C,R,O)*F.get(H,W,P,B)}I.set(E,M,_,C,W)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var Ua={kernelName:a.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.filter,u=r.inputShape,d=r.strides,p=r.pad,l=r.dataFormat,c=r.dimRoundingMode;s([i,o],"conv2dBackpropInput");var f=a.util.computeStrides(o.shape),h=a.util.computeStrides(i.shape),m=a.backend_util.convertConv2DDataFormat(l),v=a.backend_util.computeConv2DInfo(u,o.shape,d,1,p,c,!1,m),k=new a.TensorBuffer(v.inShape,"float32"),b=k.values,g=n.data.get(i.dataId).values,I=n.data.get(o.dataId).values,y=f[0],N=f[1],x=f[2],T=v.batchSize,S=v.filterHeight,F=v.filterWidth,M=v.inChannels,A=v.inHeight,D=v.inWidth,_=v.outChannels,w=v.outHeight,z=v.outWidth,C=v.strideHeight,W=v.strideWidth;m=v.dataFormat;for(var E=S-1-v.padInfo.top,H=F-1-v.padInfo.left,P="channelsLast"===m,R=k.strides[0],B=P?k.strides[1]:k.strides[2],O=P?k.strides[2]:1,L=P?1:k.strides[1],V=h[0],q=P?h[1]:h[2],G=P?h[2]:1,U=P?1:h[1],Z=0;Z<T;++Z)for(var j=0;j<M;++j)for(var K=0;K<A;++K)for(var Y=K-E,$=Math.max(0,Math.ceil(Y/C)),J=Math.min(w,(S+Y)/C),Q=0;Q<D;++Q){for(var X=Q-H,ee=Math.max(0,Math.ceil(X/W)),ae=Math.min(z,(F+X)/W),te=0,ne=$;ne<J;++ne)for(var re=ne*C-Y,ie=ee;ie<ae;++ie)for(var se=V*Z+q*ne+G*ie,oe=y*(S-1-re)+N*(F-1-(ie*W-X))+x*j,ue=0;ue<_;++ue){te+=g[se+U*ue]*I[oe+ue]}b[R*Z+B*K+O*Q+L*j]=te}return n.makeTensorInfo(k.shape,k.dtype,k.values)}};var Za={kernelName:a.Conv3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,u=r.strides,d=r.pad,p=r.dilations;s([i,o],"conv3d");for(var l=a.backend_util.computeConv3DInfo(i.shape,o.shape,u,p,d),c=l.filterDepth,f=l.filterHeight,h=l.filterWidth,m=l.dilationDepth,v=l.dilationHeight,k=l.dilationWidth,b=l.padInfo,g=b.front,I=b.left,y=b.top,N=new a.TensorBuffer(l.outShape,i.dtype),x=n.data.get(i.dataId).values,T=n.data.get(o.dataId).values,S=N.values,F=a.util.computeStrides(i.shape),M=a.util.computeStrides(o.shape),A=0;A<l.batchSize;++A)for(var D=A*F[0],_=A*N.strides[0],w=0;w<l.outDepth;++w)for(var z=_+w*N.strides[1],C=w*l.strideDepth-g,W=0;W<c;++W){var E=C+W*m;if(!(E<0||E>=l.inDepth))for(var H=W*M[0],P=D+E*F[1],R=0;R<l.outHeight;++R)for(var B=z+R*N.strides[2],O=R*l.strideHeight-y,L=0;L<f;++L){var V=O+L*v;if(!(V<0||V>=l.inHeight))for(var q=H+L*M[1],G=P+V*F[2],U=0;U<l.outWidth;++U)for(var Z=B+U*l.outChannels,j=U*l.strideWidth-I,K=0;K<h;++K){var Y=j+K*k;if(!(Y<0||Y>=l.inWidth))for(var $=q+K*M[2],J=G+Y*l.inChannels,Q=$,X=0;X<l.inChannels;++X){for(var ee=x[J+X],ae=0;ae<l.outChannels;++ae)S[Z+ae]+=ee*T[Q+ae];Q+=l.outChannels}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};var ja={kernelName:a.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.dy,u=r.strides,d=r.pad,p=r.filterShape;s([i,o],"conv3dBackpropFilterV2");for(var l=a.util.computeStrides(i.shape),c=a.util.computeStrides(o.shape),f=a.backend_util.computeConv3DInfo(i.shape,p,u,1,d),h=f.strideDepth,m=f.strideHeight,v=f.strideWidth,k=f.filterDepth,b=f.filterHeight,g=f.filterWidth,I=new a.TensorBuffer(f.filterShape,"float32"),y=I.values,N=I.strides,x=N[0],T=N[1],S=N[2],F=N[3],M=n.data.get(o.dataId).values,A=c[0],D=c[1],_=c[2],w=c[3],z=n.data.get(i.dataId).values,C=l[0],W=l[1],E=l[2],H=l[3],P=f.padInfo.front,R=f.padInfo.left,B=f.padInfo.top,O=0;O<k;++O)for(var L=Math.max(0,Math.ceil((P-O)/h)),V=Math.min(f.outDepth,(f.inDepth+P-O)/h),q=O*x,G=0;G<b;++G)for(var U=Math.max(0,Math.ceil((B-G)/m)),Z=Math.min(f.outHeight,(f.inHeight+B-G)/m),j=G*T+q,K=0;K<g;++K)for(var Y=Math.max(0,Math.ceil((R-K)/v)),$=Math.min(f.outWidth,(f.inWidth+R-K)/v),J=K*S+j,Q=0;Q<f.inChannels;++Q)for(var X=Q*F+J,ee=0;ee<f.outChannels;++ee){for(var ae=0,te=0;te<f.batchSize;++te)for(var ne=te*C,re=te*A,ie=L;ie<V;++ie)for(var se=(O+ie*h-P)*W+ne,oe=ie*D+re,ue=U;ue<Z;++ue)for(var de=(G+ue*m-B)*E+se,pe=ue*_+oe,le=Y;le<$;++le){var ce=le*w+pe;ae+=z[(K+le*v-R)*H+de+Q]*M[ce+ee]}y[X+ee]=ae}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var Ka={kernelName:a.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.filter,u=r.pad,d=r.strides,p=r.inputShape;s([i],"conv3dBackpropInputV2");for(var l=a.util.computeStrides(i.shape),c=a.util.computeStrides(o.shape),f=a.backend_util.computeConv3DInfo(p,o.shape,d,1,u),h=new a.TensorBuffer(f.inShape,"float32"),m=h.values,v=h.strides,k=v[0],b=v[1],g=v[2],I=v[3],y=n.data.get(i.dataId).values,N=l[0],x=l[1],T=l[2],S=l[3],F=n.data.get(o.dataId).values,M=c[0],A=c[1],D=c[2],_=c[3],w=f.batchSize,z=f.filterDepth,C=f.filterHeight,W=f.filterWidth,E=f.inChannels,H=f.inDepth,P=f.inHeight,R=f.inWidth,B=f.outChannels,O=f.outDepth,L=f.outHeight,V=f.outWidth,q=f.strideDepth,G=f.strideHeight,U=f.strideWidth,Z=z-1-f.padInfo.front,j=C-1-f.padInfo.top,K=W-1-f.padInfo.left,Y=0;Y<w;++Y)for(var $=0;$<E;++$)for(var J=0;J<H;++J)for(var Q=J-Z,X=Math.max(0,Math.ceil(Q/q)),ee=Math.min(O,(z+Q)/q),ae=0;ae<P;++ae)for(var te=ae-j,ne=Math.max(0,Math.ceil(te/G)),re=Math.min(L,(C+te)/G),ie=0;ie<R;++ie){for(var se=ie-K,oe=Math.max(0,Math.ceil(se/U)),ue=Math.min(V,(W+se)/U),de=0,pe=X;pe<ee;++pe)for(var le=pe*q-Q,ce=ne;ce<re;++ce)for(var fe=ce*G-te,he=oe;he<ue;++he)for(var me=N*Y+x*pe+T*ce+S*he,ve=M*(z-1-le)+A*(C-1-fe)+D*(W-1-(he*U-se))+_*$,ke=0;ke<B;++ke){de+=y[me+ke]*F[ve+ke]}m[k*Y+b*J+g*ae+I*ie+$]=de}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},Ya=_(a.Cos,(function(e){return Math.cos(e)})),$a={kernelName:a.Cos,backendName:"cpu",kernelFunc:Ya},Ja=_(a.Cosh,(function(e){return Math.cosh(e)})),Qa={kernelName:a.Cosh,backendName:"cpu",kernelFunc:Ja};var Xa={kernelName:a.CropAndResize,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=e.backend,r=e.attrs,i=t.image,s=t.boxes,o=t.boxInd,u=r.cropSize,d=r.method,p=r.extrapolationValue,l=i.shape,c=l[0],f=l[1],h=l[2],m=l[3],v=s.shape[0],k=u[0],b=u[1],g=a.buffer([v,k,b,m],"float32"),I=n.data.get(s.dataId).values,y=n.data.get(o.dataId).values,N=n.data.get(i.dataId).values,x=a.util.computeStrides(i.shape),T=a.util.computeStrides(g.shape),S=0;S<v;S++){var F=4*S,M=I[F],A=I[F+1],D=I[F+2],_=I[F+3],w=y[S];if(!(w>=c))for(var z=k>1?(D-M)*(f-1)/(k-1):0,C=b>1?(_-A)*(h-1)/(b-1):0,W=0;W<k;W++){var E=k>1?M*(f-1)+W*z:.5*(M+D)*(f-1);if(E<0||E>f-1)for(var H=0;H<b;H++)for(var P=0;P<m;P++){var R=P+H*T[2]+W*T[1]+S*T[0];g.values[R]=p}else if("bilinear"===d){var B=Math.floor(E),O=Math.ceil(E),L=E-B;for(H=0;H<b;H++){if(($=b>1?A*(h-1)+H*C:.5*(A+_)*(h-1))<0||$>h-1)for(P=0;P<m;P++){R=P+H*T[2]+W*T[1]+S*T[0];g.values[R]=p}else{var V=Math.floor($),q=Math.ceil($),G=$-V;for(P=0;P<m;P++){var U=N[R=P+V*x[2]+B*x[1]+w*x[0]],Z=N[R=P+q*x[2]+B*x[1]+w*x[0]],j=N[R=P+V*x[2]+O*x[1]+w*x[0]],K=U+(Z-U)*G,Y=j+(N[R=P+q*x[2]+O*x[1]+w*x[0]]-j)*G;R=P+H*T[2]+W*T[1]+S*T[0],g.values[R]=K+(Y-K)*L}}}}else for(H=0;H<b;++H){var $;if(($=b>1?A*(h-1)+H*C:.5*(A+_)*(h-1))<0||$>h-1)for(P=0;P<m;P++){R=P+H*T[2]+W*T[1]+S*T[0];g.values[R]=p}else{var J=Math.round($),Q=Math.round(E);for(P=0;P<m;P++){var X=P+J*x[2]+Q*x[1]+w*x[0],ee=P+H*T[2]+W*T[1]+S*T[0];g.values[ee]=N[X]}}}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var et={kernelName:a.Cumsum,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,u=r.exclusive,d=r.reverse;s(i,"cumsum");var p=a.backend_util.getAxesPermutation([o],i.shape.length),l=i;null!=p&&(l=ge({inputs:{x:i},backend:n,attrs:{perm:p}}));var c=a.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(c!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(l.shape.length-1)+" but got axis="+c);for(var f=a.upcastType(l.dtype,"int32"),h=a.util.makeZerosTypedArray(a.util.sizeFromShape(l.shape),f),m=n.data.get(l.dataId).values,v=l.shape[l.shape.length-1],k=d?function(e,a){return e+v-a-1}:function(e,a){return e+a},b=0;b<m.length;b+=v)for(var g=0;g<v;g++){var I=k(b,g);if(0===g)h[I]=u?0:m[I];else{var y=k(b,g-1);h[I]=u?m[y]+h[y]:m[I]+h[y]}}var N=n.makeTensorInfo(l.shape,f,h);if(null!=p){var x=ge({inputs:{x:N},backend:n,attrs:{perm:a.backend_util.getUndoAxesPermutation(p)}});return n.disposeIntermediateTensorInfo(N),n.disposeIntermediateTensorInfo(l),x}return N}};var at={kernelName:a.DenseBincount,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=a.weights,s=n.size,o=n.binaryOutput;if(1===r.shape.length){var u=M(t.data.get(r.dataId).values,t.data.get(i.dataId).values,i.dtype,i.shape,s);return t.makeTensorInfo([s],i.dtype,u)}if(2===r.shape.length){var d=A(t.bufferSync(r),t.bufferSync(i),s,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+r.shape.length+".")}};var tt={kernelName:a.DepthToSpace,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,s=r.blockSize,o=r.dataFormat;a.util.assert("NHWC"===o,(function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+o})),a.util.assert(s>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: "+s}));for(var u=i.shape[0],d=i.shape[1],p=i.shape[2],l=i.shape[3],c=d*s,f=p*s,h=l/(s*s),m=n.data.get(i.dataId).values,v=new Float32Array(u*c*f*h),k=0,b=0;b<u;++b)for(var g=0;g<c;++g)for(var I=Math.floor(g/s),y=g%s,N=0;N<f;++N)for(var x=Math.floor(N/s),T=(y*s+N%s)*h,S=0;S<h;++S){var F=S+T+l*(x+p*(I+d*b));v[k++]=m[F]}return n.makeTensorInfo([u,c,f,h],i.dtype,v)}};function nt(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.filter,u=r.strides,d=r.pad,p=r.dilations,l=r.dimRoundingMode;s([i,o],"depthwiseConv2DNative");var c=a.util.computeStrides(i.shape),f=a.util.computeStrides(o.shape),h=p;null==h&&(h=[1,1]),a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(u,h),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+u+" and dilations '"+h+"'"}));for(var m=a.backend_util.computeConv2DInfo(i.shape,o.shape,u,h,d,l,!0),v=m.filterHeight,k=m.filterWidth,b=m.dilationHeight,g=m.dilationWidth,I=m.padInfo,y=I.left,N=I.top,x=m.outChannels/m.inChannels,T=new a.TensorBuffer(m.outShape,i.dtype),S=n.data.get(i.dataId).values,F=n.data.get(o.dataId).values,M=T.values,A=0;A<m.batchSize;++A)for(var D=A*c[0],_=A*T.strides[0],w=0;w<m.outHeight;++w)for(var z=_+w*T.strides[1],C=w*m.strideHeight-y,W=0;W<v;++W){var E=C+W*b;if(!(E<0||E>=m.inHeight))for(var H=W*f[0],P=D+E*c[1],R=0;R<m.outWidth;++R)for(var B=z+R*T.strides[2],O=R*m.strideWidth-N,L=0;L<k;++L){var V=O+L*g;if(!(V<0||V>=m.inWidth))for(var q=H+L*f[1],G=P+V*m.inChannels,U=B,Z=q,j=0;j<m.inChannels;++j){for(var K=S[G+j],Y=0;Y<x;++Y)M[U+Y]+=K*F[Z+Y];U+=x,Z+=x}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var rt={kernelName:a.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:nt};var it={kernelName:a.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.dy,u=r.strides,d=r.dilations,p=r.pad,l=r.dimRoundingMode,c=r.filterShape;s([i,o],"depthwiseConv2dNativeBackpropFilter");for(var f=a.backend_util.computeConv2DInfo(i.shape,c,u,d,p,l,!0),h=f.strideHeight,m=f.strideWidth,v=f.filterHeight,k=f.filterWidth,b=new a.TensorBuffer(f.filterShape,"float32"),g=f.padInfo.left,I=f.padInfo.top,y=f.outChannels/f.inChannels,N=n.data.get(i.dataId).values,x=new a.TensorBuffer(i.shape,i.dtype,N),T=n.data.get(o.dataId).values,S=new a.TensorBuffer(o.shape,o.dtype,T),F=0;F<v;++F)for(var M=Math.max(0,Math.ceil((I-F)/h)),A=Math.min(f.outHeight,(f.inHeight+I-F)/h),D=0;D<k;++D)for(var _=Math.max(0,Math.ceil((g-D)/m)),w=Math.min(f.outWidth,(f.inWidth+g-D)/m),z=0;z<f.outChannels;++z){for(var C=Math.trunc(z/y),W=z%y,E=0,H=0;H<f.batchSize;++H)for(var P=M;P<A;++P)for(var R=F+P*h-I,B=_;B<w;++B){var O=D+B*m-g;E+=x.get(H,R,O,C)*S.get(H,P,B,z)}b.set(E,F,D,C,W)}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var st={kernelName:a.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.filter,u=r.strides,d=r.dilations,p=r.pad,l=r.dimRoundingMode,c=r.inputShape;s([i,o],"depthwiseConv2DNativeBackpropInput");for(var f=a.util.computeStrides(i.shape),h=a.util.computeStrides(o.shape),m=a.backend_util.computeConv2DInfo(c,o.shape,u,d,p,l,!0),v=new a.TensorBuffer(m.inShape,"float32"),k=v.values,b=v.strides,g=b[0],I=b[1],y=b[2],N=n.data.get(i.dataId).values,x=f[0],T=f[1],S=f[2],F=n.data.get(o.dataId).values,M=h[0],A=h[1],D=h[2],_=m.batchSize,w=m.filterHeight,z=m.filterWidth,C=m.inChannels,W=m.inHeight,E=m.inWidth,H=m.outChannels,P=m.outHeight,R=m.outWidth,B=m.strideHeight,O=m.strideWidth,L=w-1-m.padInfo.top,V=z-1-m.padInfo.left,q=H/C,G=0;G<_;++G)for(var U=0;U<C;++U)for(var Z=0;Z<W;++Z)for(var j=Z-L,K=Math.max(0,Math.ceil(j/B)),Y=Math.min(P,(w+j)/B),$=0;$<E;++$){for(var J=$-V,Q=Math.max(0,Math.ceil(J/O)),X=Math.min(R,(z+J)/O),ee=0,ae=K;ae<Y;++ae)for(var te=ae*B-j,ne=Q;ne<X;++ne)for(var re=x*G+T*ae+S*ne,ie=M*(w-1-te)+A*(z-1-(ne*O-J))+D*U,se=0;se<q;++se){ee+=N[re+(U*q+se)]*F[ie+se]}k[g*G+I*Z+y*$+U]=ee}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};var ot={kernelName:a.Diag,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=e.backend,r=t.x,i=a.util.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,o=a.buffer([i,i],r.dtype),u=o.values,d=0;d<s.length;d++)u[d*i+d]=s[d];var p=r.shape.concat(r.shape);return n.makeTensorInfo(p,o.dtype,o.values)}},ut={kernelName:a.Dilation2D,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=e.backend,r=e.attrs,i=t,s=i.x,o=i.filter,u=r,d=u.strides,p=u.pad,l=u.dilations,c=n,f=c.data.get(s.dataId).values,h=s.shape.length,m=c.data.get(o.dataId).values,v=o.shape.length,k=a.backend_util.computeDilation2DInfo(s.shape,o.shape,d,p,"NHWC",l),b=k.batchSize,g=k.inHeight,I=k.inWidth,y=k.inChannels,N=k.outHeight,x=k.outWidth,T=k.padInfo,S=k.strideHeight,F=k.strideWidth,M=k.filterHeight,A=k.filterWidth,D=k.dilationHeight,_=k.dilationWidth,w=k.outShape,z=a.util.sizeFromShape(w),C=w.length,W=a.util.getArrayFromDType(s.dtype,z),E=0;E<b;++E)for(var H=0;H<N;++H)for(var P=H*S-T.top,R=0;R<x;++R)for(var B=R*F-T.left,O=0;O<y;++O){for(var L=Number.MIN_SAFE_INTEGER,V=0;V<M;++V){var q=P+V*D;if(q>=0&&q<g)for(var G=0;G<A;++G){var U=B+G*_;if(U>=0&&U<I){var Z=a.util.locToIndex([E,q,U,O],h,a.util.computeStrides(s.shape)),j=a.util.locToIndex([V,G,O],v,a.util.computeStrides(o.shape)),K=f[Z]+m[j];K>L&&(L=K)}}}W[a.util.locToIndex([E,H,R,O],C,a.util.computeStrides(w))]=L}return{dataId:c.write(a.util.toTypedArray(W,s.dtype),w,s.dtype),shape:w,dtype:s.dtype}}},dt={kernelName:a.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t,s=i.x,o=i.filter,u=i.dy,d=r,p=d.strides,l=d.pad,c=d.dilations,f=n,h=a.util.toNestedArray(s.shape,f.data.get(s.dataId).values),m=a.util.toNestedArray(o.shape,f.data.get(o.dataId).values),v=a.backend_util.computeDilation2DInfo(s.shape,o.shape,p,l,"NHWC",c),k=v.batchSize,b=v.inHeight,g=v.inWidth,I=v.inChannels,y=v.outHeight,N=v.outWidth,x=v.padInfo,T=v.strideHeight,S=v.strideWidth,F=v.filterHeight,M=v.filterWidth,A=v.dilationHeight,D=v.dilationWidth,_=v.outShape;a.util.assert(u.rank===_.length,(function(){return"Error in "+a.Dilation2DBackpropFilter+", dy must have the same rank as output "+_.length+", but got "+u.rank}));for(var w=a.util.toNestedArray(_,f.data.get(u.dataId).values),z=a.util.makeZerosNestedTypedArray(o.shape,o.dtype),C=0;C<k;++C)for(var W=0;W<y;++W)for(var E=W*T-x.top,H=0;H<N;++H)for(var P=H*S-x.left,R=0;R<I;++R){for(var B=Number.MIN_SAFE_INTEGER,O=0,L=0,V=0;V<F;++V){var q=E+V*A;if(q>=0&&q<b)for(var G=0;G<M;++G){var U=P+G*D;if(U>=0&&U<g){var Z=h[C][q][U][R]+m[V][G][R];Z>B&&(B=Z,O=V,L=G)}}}z[O][L][R]+=w[C][W][H][R]}return{dataId:f.write(a.util.toTypedArray(z,s.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},pt={kernelName:a.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t,s=i.x,o=i.filter,u=i.dy,d=r,p=d.strides,l=d.pad,c=d.dilations,f=n,h=a.util.toNestedArray(s.shape,f.data.get(s.dataId).values),m=a.util.toNestedArray(o.shape,f.data.get(o.dataId).values),v=a.backend_util.computeDilation2DInfo(s.shape,o.shape,p,l,"NHWC",c),k=v.batchSize,b=v.inHeight,g=v.inWidth,I=v.inChannels,y=v.outHeight,N=v.outWidth,x=v.padInfo,T=v.strideHeight,S=v.strideWidth,F=v.filterHeight,M=v.filterWidth,A=v.dilationHeight,D=v.dilationWidth,_=v.outShape;a.util.assert(u.rank===_.length,(function(){return"Error in "+a.Dilation2DBackpropInput+", dy must have the same rank as output "+_.length+", but got "+u.rank}));for(var w=a.util.toNestedArray(_,f.data.get(u.dataId).values),z=a.util.makeZerosNestedTypedArray(s.shape,s.dtype),C=0;C<k;++C)for(var W=0;W<y;++W)for(var E=W*T-x.top,H=0;H<N;++H)for(var P=H*S-x.left,R=0;R<I;++R){for(var B=Number.MIN_SAFE_INTEGER,O=E<0?0:E,L=P<0?0:P,V=0;V<F;++V){var q=E+V*A;if(q>=0&&q<b)for(var G=0;G<M;++G){var U=P+G*D;if(U>=0&&U<g){var Z=h[C][q][U][R]+m[V][G][R];Z>B&&(B=Z,O=q,L=U)}}}z[C][O][L][R]+=w[C][W][H][R]}return{dataId:f.write(a.util.toTypedArray(z,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function lt(e){var t,n=e.inputs,r=e.backend,i=e.attrs,o=n.x,u=i.axis,d=i.keepDims;s(o,"sum");var p=(t="bool"===o.dtype?g({inputs:{x:o},backend:r,attrs:{dtype:"int32"}}):m({inputs:{x:o},backend:r})).shape.length,l=a.util.parseAxisParam(u,t.shape),c=a.backend_util.getAxesPermutation(l,p),f=l,v=t;null!=c&&(v=ge({inputs:{x:t},backend:r,attrs:{perm:c}}),f=a.backend_util.getInnerMostAxes(f.length,p)),a.backend_util.assertAxesAreInnerMostDims("sum",f,v.shape.length);for(var k=a.backend_util.computeOutAndReduceShapes(v.shape,f),b=k[0],I=k[1],y=h(r,b,a.backend_util.upcastType(v.dtype,"int32")),N=a.util.sizeFromShape(I),x=r.data.get(y.dataId).values,T=r.data.get(v.dataId).values,S=0;S<x.length;++S){for(var F=S*N,M=0,A=0;A<N;++A)M+=T[F+A];x[S]=M}if(d){var D=y;y=ea({inputs:{x:y},backend:r,attrs:{shape:a.backend_util.expandShapeToKeepDim(y.shape,l)}}),r.disposeIntermediateTensorInfo(D)}return r.disposeIntermediateTensorInfo(t),null!=c&&r.disposeIntermediateTensorInfo(v),y}var ct={kernelName:a.Sum,backendName:"cpu",kernelFunc:lt};var ft={kernelName:a.Einsum,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs.equation,i=t,s=a.backend_util.decodeEinsumEquation(r,i.length),o=s.allDims,u=s.summedDims,d=s.idDims;a.backend_util.checkEinsumDimSizes(o.length,d,i);for(var p=a.backend_util.getEinsumComputePath(u,d),l=p.path,c=p.steps,f=c.length,h=null,m=o.length,v=[],k=0;k<f;++k){for(var b=0,g=c[k];b<g.length;b++){var I=g[b],y=a.backend_util.getEinsumPermutation(m,d[I]),N=y.permutationIndices,x=y.expandDims,T=void 0;a.backend_util.isIdentityPermutation(N)?T=i[I]:(T=ge({inputs:{x:i[I]},backend:n,attrs:{perm:N}}),v.push(T));for(var S=T.shape.slice(),F=0;F<x.length;++F)S.splice(x[F],0,1);a.util.arraysEqual(T.shape,S)||(T=ea({inputs:{x:T},backend:n,attrs:{shape:S}}),v.push(T)),null===h?h=T:(h=le({inputs:{a:T,b:h},backend:n}),v.push(h))}k<f-1&&(l[k]>=0&&(h=lt({inputs:{x:h},backend:n,attrs:{axis:l[k]-(o.length-m),keepDims:!1}}),v.push(h)),m--)}for(var M=0,A=v;M<A.length;M++){var D=A[M];D!==h&&n.disposeIntermediateTensorInfo(D)}return h}};var ht={kernelName:a.EluGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.dy,i=t.y;s([r,i],"eluGrad");for(var o=new Float32Array(a.util.sizeFromShape(i.shape)),u=n.data.get(i.dataId).values,d=n.data.get(r.dataId).values,p=0;p<u.length;++p){var l=u[p];o[p]=l>=1?d[p]:d[p]*(l+1)}return n.makeTensorInfo(i.shape,"float32",o)}},mt=l((function(e,a){return e===a?1:0})),vt=y(a.Equal,mt,null,"bool"),kt={kernelName:a.Equal,backendName:"cpu",kernelFunc:vt},bt=a.backend_util.ERF_P,gt=a.backend_util.ERF_A1,It=a.backend_util.ERF_A2,yt=a.backend_util.ERF_A3,Nt=a.backend_util.ERF_A4,xt=a.backend_util.ERF_A5,Tt=_(a.Erf,(function(e){var a=Math.sign(e),t=Math.abs(e),n=1/(1+bt*t);return a*(1-((((xt*n+Nt)*n+yt)*n+It)*n+gt)*n*Math.exp(-t*t))})),St={kernelName:a.Erf,backendName:"cpu",kernelFunc:Tt};function Ft(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.input,s=r.dim,o=i.shape.length,u=i.shape.slice(),d=s;return s<0&&(a.util.assert(-(o+1)<=s,(function(){return"Axis must be in the interval ["+-(o+1)+", "+o+"]"})),d=o+s+1),u.splice(d,0,1),ea({inputs:{x:i},backend:n,attrs:{shape:u}})}var Mt={kernelName:a.ExpandDims,backendName:"cpu",kernelFunc:Ft},At=l((function(e,a){return e/a})),Dt=y(a.RealDiv,At),_t={kernelName:a.RealDiv,backendName:"cpu",kernelFunc:Dt};function wt(e,t,n){for(var r=e.shape,i=r[0],s=r[1],o=n.data.get(e.dataId),u=o.complexTensorInfos.real,d=o.complexTensorInfos.imag,p=[i,s],l=a.util.sizeFromShape(p),f=a.util.getTypedArrayFromDType("float32",l),h=a.util.getTypedArrayFromDType("float32",l),m=0;m<i;m++){for(var v=Ae({inputs:{x:u},backend:n,attrs:{begin:[m,0],size:[1,s]}}),k=Ae({inputs:{x:d},backend:n,attrs:{begin:[m,0],size:[1,s]}}),b=c({inputs:{real:v,imag:k},backend:n}),g=zt(b,t,n),I=g.real,y=g.imag,N=a.backend_util.mergeRealAndImagArrays(I,y),x=0;x<s;x++){var T=a.backend_util.getComplexWithIndex(N,x);f[m*s+x]=T.real,h[m*s+x]=T.imag}n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(b)}var S=n.makeTensorInfo(p,"float32",f),F=n.makeTensorInfo(p,"float32",h),M=c({inputs:{real:S,imag:F},backend:n});return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(F),M}function zt(e,t,n){var r=a.util.sizeFromShape(e.shape),i=n.data.get(e.dataId),s=n.data.get(i.complexTensorInfos.real.dataId).values,o=n.data.get(i.complexTensorInfos.imag.dataId).values;if(0==((y=r)&y-1)){var u=function e(t,n,r,i,s){if(1===r)return{real:t,imag:n};var o=a.backend_util.mergeRealAndImagArrays(t,n),u=r/2,d=a.backend_util.complexWithEvenIndex(o),p=d.real,l=d.imag,f=[p.length],h=s.makeTensorInfo(f,"float32",p),m=s.makeTensorInfo(f,"float32",l),v=c({inputs:{real:h,imag:m},backend:s}),b=a.backend_util.complexWithOddIndex(o),g=b.real,I=b.imag,y=[g.length],N=s.makeTensorInfo(y,"float32",g),x=s.makeTensorInfo(y,"float32",I),T=c({inputs:{real:N,imag:x},backend:s}),F=e(p,l,u,i,s),M=F.real,A=F.imag,D=[M.length],_=s.makeTensorInfo(D,"float32",M),w=s.makeTensorInfo(D,"float32",A),z=c({inputs:{real:_,imag:w},backend:s}),C=e(g,I,u,i,s),W=C.real,E=C.imag,H=[W.length],P=s.makeTensorInfo(H,"float32",W),R=s.makeTensorInfo(H,"float32",E),B=c({inputs:{real:P,imag:R},backend:s}),O=a.backend_util.exponents(r,i),L=[O.real.length],V=s.makeTensorInfo(L,"float32",O.real),q=s.makeTensorInfo(L,"float32",O.imag),G=c({inputs:{real:V,imag:q},backend:s}),U=le({inputs:{a:G,b:B},backend:s}),Z=S({inputs:{a:z,b:U},backend:s}),j=He({inputs:{a:z,b:U},backend:s}),K=k({inputs:{input:Z},backend:s}),Y=k({inputs:{input:j},backend:s}),$=Ra({inputs:{input:Z},backend:s}),J=Ra({inputs:{input:j},backend:s}),Q=Oa({inputs:[K,Y],backend:s,attrs:{axis:0}}),X=Oa({inputs:[$,J],backend:s,attrs:{axis:0}}),ee=s.data.get(Q.dataId).values,ae=s.data.get(X.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(Z),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(J),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(X),{real:ee,imag:ae}}(s,o,r,t,n),d=[e.shape[0],e.shape[1]];if(t){var p=n.makeTensorInfo(d,"float32",u.real),l=n.makeTensorInfo(d,"float32",u.imag),f=n.makeTensorInfo([],"float32",a.util.createScalarValue(r,"float32")),h=m({inputs:{x:f},backend:n}),v=_t.kernelFunc({inputs:{a:p,b:f},backend:n}),b=_t.kernelFunc({inputs:{a:l,b:h},backend:n}),g=n.data.get(v.dataId).values,I=n.data.get(b.dataId).values;return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(b),{real:g,imag:I}}return u}var y,N=function(e,t,n){for(var r=new Float32Array(2*t),i=0;i<t;i++){for(var s=0,o=0,u=0;u<t;u++){var d=a.backend_util.exponent(i*u,t,n),p=a.backend_util.getComplexWithIndex(e,u);s+=p.real*d.real-p.imag*d.imag,o+=p.real*d.imag+p.imag*d.real}n&&(s/=t,o/=t),a.backend_util.assignToTypedArray(r,s,o,i)}return r}(a.backend_util.mergeRealAndImagArrays(s,o),r,t);return a.backend_util.splitRealAndImagArrays(N)}var Ct={kernelName:a.FFT,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.input,i=a.util.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],o=ea({inputs:{x:r},backend:n,attrs:{shape:[i/s,s]}}),u=wt(o,!1,n),d=ea({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),d}};function Wt(e){var t=e.backend,n=e.attrs,r=n.shape,i=n.value,s=n.dtype||a.util.inferDtype(i),o=a.util.getArrayFromDType(s,a.util.sizeFromShape(r));return function(e,a,t){e.fill(a)}(o,i),t.makeTensorInfo(r,s,o)}var Et={kernelName:a.Fill,backendName:"cpu",kernelFunc:Wt};var Ht={kernelName:a.FlipLeftRight,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=(e.attrs,e.backend),r=t.image,i=n,s=a.util.getTypedArrayFromDType(r.dtype,a.util.sizeFromShape(r.shape)),o=r.shape,u=o[0],d=o[1],p=o[2],l=o[3],c=i.data.get(r.dataId).values,f=0;f<u;f++)for(var h=f*p*d*l,m=0;m<d;m++)for(var v=m*(p*l),k=0;k<p;k++)for(var b=k*l,g=0;g<l;g++){var I=[u,m,k,g][2],y=Math.round(p-I),N=h+v+b+g,x=c[N];if(y>=0&&y<p)x=c[h+v+y*l+g];s[N]=x}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Pt=l((function(e,a){return Math.floor(e/a)})),Rt=y(a.FloorDiv,Pt,null,"int32"),Bt={kernelName:a.FloorDiv,backendName:"cpu",kernelFunc:Rt};var Ot={kernelName:a.FusedConv2D,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=a.filter,s=a.bias,o=a.preluActivationWeights,u=n.strides,d=n.pad,p=n.dataFormat,l=n.dilations,c=n.dimRoundingMode,f=n.activation,h=n.leakyreluAlpha,m=Va({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:d,dataFormat:p,dilations:l,dimRoundingMode:c}});if(s){var v=m;m=S({inputs:{a:m,b:s},backend:t}),t.disposeIntermediateTensorInfo(v)}if(f){v=m;m=Xe(t,m,f,o,h),t.disposeIntermediateTensorInfo(v)}return m}};var Lt={kernelName:a.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=a.filter,s=a.bias,o=a.preluActivationWeights,u=n.strides,d=n.pad,p=n.dataFormat,l=n.dilations,c=n.dimRoundingMode,f=n.activation,h=n.leakyreluAlpha,m=nt({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:d,dataFormat:p,dilations:l,dimRoundingMode:c}});if(s){var v=m;m=S({inputs:{a:m,b:s},backend:t}),t.disposeIntermediateTensorInfo(v)}if(f){v=m;m=Xe(t,m,f,o,h),t.disposeIntermediateTensorInfo(v)}return m}};var Vt={kernelName:a.GatherNd,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.params,i=t.indices,s=a.util.sizeFromShape(r.shape),o=i.shape,u=o[o.length-1],d=a.backend_util.prepareAndValidate(r,i),p=d[0],l=d[1],c=d[2],f=d[3];if(0===l)return n.makeTensorInfo(p,r.dtype,[]);for(var h=a.buffer([l,c],r.dtype),m=n.data.get(i.dataId).values,v=n.data.get(r.dataId).values,k=0;k<l;k++){for(var b=[],g=0,I=0;I<u;I++){var y=m[k*u+I];g+=y*f[I],b.push(y)}if(g<0||g>=s/c)throw new Error("Invalid indices: "+b+" does not index into "+r.shape);for(var N=0;N<c;N++)h.values[k*c+N]=v[g*c+N]}return n.makeTensorInfo(p,h.dtype,h.values)}};var qt={kernelName:a.GatherV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.indices,u=r.axis,d=r.batchDims;s([i,o],"gatherV2");var p=d;null==d&&(p=0);var l=a.util.sizeFromShape(o.shape),c=a.util.parseAxisParam(u,i.shape)[0],f=a.backend_util.segment_util.collectGatherOpShapeInfo(i,o,c,p),h=ea({inputs:{x:i},backend:n,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),m=ea({inputs:{x:o},backend:n,attrs:{shape:[f.batchSize,l/f.batchSize]}}),v=[f.batchSize,f.outerSize,l/f.batchSize,f.sliceSize],k=n.bufferSync(m),b=U(n.bufferSync(h),k,v);return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(f.outputShape,b.dtype,b.values)}},Gt=l((function(e,a){return e>=a?1:0})),Ut=y(a.GreaterEqual,Gt,null,"bool"),Zt={kernelName:a.GreaterEqual,backendName:"cpu",kernelFunc:Ut};var jt={kernelName:a.IFFT,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.input,i=a.util.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],o=ea({inputs:{x:r},backend:n,attrs:{shape:[i/s,s]}}),u=wt(o,!0,n),d=ea({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),d}},Kt=_(a.IsFinite,(function(e){return Number.isFinite(e)?1:0}),"bool"),Yt={kernelName:a.IsFinite,backendName:"cpu",kernelFunc:Kt},$t=_(a.IsInf,(function(e){return Math.abs(e)===1/0?1:0}),"bool"),Jt={kernelName:a.IsInf,backendName:"cpu",kernelFunc:$t},Qt=_(a.IsNan,(function(e){return Number.isNaN(e)?1:0}),"bool"),Xt={kernelName:a.IsNan,backendName:"cpu",kernelFunc:Qt},en=l((function(e,a){return e<=a?1:0})),an=y(a.LessEqual,en,null,"bool"),tn={kernelName:a.LessEqual,backendName:"cpu",kernelFunc:an};var nn={kernelName:a.LinSpace,backendName:"cpu",kernelFunc:function(e){var a=e.backend,t=e.attrs,n=Q(t.start,t.stop,t.num);return a.makeTensorInfo([n.length],"float32",n)}},rn=_(a.Log1p,(function(e){return Math.log1p(e)})),sn={kernelName:a.Log1p,backendName:"cpu",kernelFunc:rn},on=l((function(e,a){return e&&a})),un=y(a.LogicalAnd,on,null,"bool"),dn={kernelName:a.LogicalAnd,backendName:"cpu",kernelFunc:un},pn=_(a.LogicalNot,(function(e){return e?0:1}),"bool"),ln={kernelName:a.LogicalNot,backendName:"cpu",kernelFunc:pn},cn=l((function(e,a){return e||a})),fn=y(a.LogicalOr,cn,null,"bool"),hn={kernelName:a.LogicalOr,backendName:"cpu",kernelFunc:fn};var mn={kernelName:a.LRN,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.depthRadius,u=r.bias,d=r.alpha,p=r.beta;s(i,"LRN");var l=i.shape[3],c=l-1,f=n.data.get(i.dataId).values,h=a.util.sizeFromShape(i.shape),m=new Float32Array(h);function v(e){for(var a=e%l,t=e-a+Math.max(0,a-o),n=e-a+Math.min(a+o,c),r=0;t<=n;t++){var i=f[t];r+=i*i}return r}for(var k=0;k<h;k++){var b=v(k),g=f[k]*Math.pow(u+d*b,-p);m[k]=g}return n.makeTensorInfo(i.shape,i.dtype,m)}};var vn={kernelName:a.LRNGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.y,u=t.dy,d=r.depthRadius,p=r.bias,l=r.alpha,c=r.beta;s(u,"LRNGrad");for(var f=a.util.sizeFromShape(u.shape),h=u.shape[3],m=n.data.get(u.dataId).values,v=n.data.get(i.dataId).values,k=n.data.get(o.dataId).values,b=new Float32Array(f),g=f,I=0;I<g;I++){for(var y=I%h,N=I-y+Math.max(0,y-d),x=I-y+Math.min(h,y+d+1),T=0,S=N;S<x;S++)T+=Math.pow(v[S],2);T=l*T+p;for(S=N;S<x;S++){var F=-2*l*c*v[S]*k[I]/T;I===S&&(F+=Math.pow(T,-c)),F*=m[I],b[S]+=F}}return n.makeTensorInfo(u.shape,i.dtype,b)}};function kn(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.reductionIndices,u=r.keepDims,d=n,p=i.shape,l=p.length,c=a.util.parseAxisParam(o,p),f=c,h=a.backend_util.getAxesPermutation(f,l),m=d.data.get(i.dataId).values;if(null!=h){for(var v=new Array(l),k=0;k<v.length;k++)v[k]=p[h[k]];m=be(m,p,i.dtype,h,v),f=a.backend_util.getInnerMostAxes(f.length,l),p=v}s(i,"max"),a.backend_util.assertAxesAreInnerMostDims("max",f,l);var b=a.backend_util.computeOutAndReduceShapes(p,f),g=b[0],I=b[1],y=te(m,a.util.sizeFromShape(I),g,i.dtype),N=d.write(y,g,i.dtype),x=g;u&&(x=v=a.backend_util.expandShapeToKeepDim(g,c));return{dataId:N,shape:x,dtype:i.dtype}}var bn={kernelName:a.Max,backendName:"cpu",kernelFunc:kn};var gn={kernelName:a.MaxPool,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x;s(i,"maxPool");var o=r.filterSize,u=r.strides,d=r.pad,p=r.dimRoundingMode;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(u,1),(function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+u+" and dilations '1'"}));var l,c=a.backend_util.computePool2DInfo(i.shape,o,u,1,d,p);if(1===c.filterWidth&&1===c.filterHeight&&a.util.arraysEqual(c.inShape,c.outShape))l=m({inputs:{x:i},backend:n});else{var f=n.data.get(i.dataId).values,h=a.util.computeStrides(i.shape),v=Sa(f,i.shape,i.dtype,h,c,"max");l=n.makeTensorInfo(c.outShape,i.dtype,v.values)}return l}};var In={kernelName:a.MaxPool3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.filterSize,u=r.strides,d=r.pad,p=r.dimRoundingMode,l=r.dataFormat;s(i,"maxPool3d");var c=a.backend_util.computePool3DInfo(i.shape,o,u,1,d,p,l),f=Ma(n.data.get(i.dataId).values,i.shape,i.dtype,a.util.computeStrides(i.shape),c,"max");return n.makeTensorInfo(f.shape,"float32",f.values)}};var yn={kernelName:a.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.input,u=r.filterSize,d=r.strides,p=r.pad,l=r.dimRoundingMode;s([i,o],"maxPool3DGrad");for(var c=a.backend_util.computePool3DInfo(o.shape,u,d,1,p,l),f=function(e,t){for(var n=a.buffer(t.outShape,"int32"),r=t.strideDepth,i=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,u=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,f=t.padInfo.front,h=t.padInfo.top,m=t.padInfo.left,v=0;v<t.batchSize;++v)for(var k=0;k<t.inChannels;++k)for(var b=0;b<t.outDepth;++b){for(var g=b*r-f,I=g;I<0;)I+=o;for(var y=Math.min(t.inDepth,p+g),N=0;N<t.outHeight;++N){for(var x=N*i-h,T=x;T<0;)T+=u;for(var S=Math.min(t.inHeight,l+x),F=0;F<t.outWidth;++F){for(var M=F*s-m,A=M;A<0;)A+=d;for(var D=Math.min(t.inWidth,c+M),_=Number.NEGATIVE_INFINITY,w=-1,z=I;z<y;z+=o)for(var C=z-g,W=T;W<S;W+=u)for(var E=W-x,H=A;H<D;H+=d){var P=H-M,R=e.get(v,z,W,H,k);R>=_&&(_=R,w=C*l*c+E*l+P)}n.set(w,v,b,N,F,k)}}}return n}(n.bufferSync(o),c),h=c.strideDepth,m=c.strideHeight,v=c.strideWidth,k=c.dilationDepth,b=c.dilationHeight,g=c.dilationWidth,I=c.effectiveFilterDepth,y=c.effectiveFilterHeight,N=c.effectiveFilterWidth,x=I-1-c.padInfo.front,T=N-1-c.padInfo.left,S=y-1-c.padInfo.top,F=a.buffer(o.shape,"float32"),M=n.bufferSync(i),A=0;A<c.batchSize;++A)for(var D=0;D<c.inChannels;++D)for(var _=0;_<c.inDepth;++_)for(var w=0;w<c.inHeight;++w)for(var z=0;z<c.inWidth;++z){for(var C=_-x,W=w-S,E=z-T,H=0,P=0;P<I;P+=k){var R=(C+P)/h;if(!(R<0||R>=c.outDepth||Math.floor(R)!==R))for(var B=0;B<y;B+=b){var O=(W+B)/m;if(!(O<0||O>=c.outHeight||Math.floor(O)!==O))for(var L=0;L<N;L+=g){var V=(E+L)/v;if(!(V<0||V>=c.outWidth||Math.floor(V)!==V)){var q=I*y*N-1-f.get(A,R,O,V,D)===P*y*N+B*N+L?1:0;if(0!==q)H+=M.get(A,R,O,V,D)*q}}}}F.set(H,A,_,w,z,D)}return n.makeTensorInfo(F.shape,F.dtype,F.values)}};var Nn={kernelName:a.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.dy,o=t.input,u=o;s([o,t.output],"maxPoolGrad");for(var d=r.filterSize,p=r.strides,l=r.pad,c=r.dimRoundingMode,f=a.backend_util.computePool2DInfo(u.shape,d,p,1,l,c),h=n.data.get(u.dataId).values,m=a.buffer(f.outShape,u.dtype,Fa(h,u.shape,u.dtype,f).values),v=f.strideHeight,k=f.strideWidth,b=f.dilationHeight,g=f.dilationWidth,I=f.effectiveFilterHeight,y=f.effectiveFilterWidth,N=y-1-f.padInfo.left,x=I-1-f.padInfo.top,T=a.buffer(u.shape,"float32"),S=n.data.get(i.dataId).values,F=a.buffer(i.shape,"float32",S),M=0;M<f.batchSize;++M)for(var A=0;A<f.inChannels;++A)for(var D=0;D<f.inHeight;++D)for(var _=0;_<f.inWidth;++_){for(var w=D-x,z=_-N,C=0,W=0;W<I;W+=b){var E=(w+W)/v;if(!(E<0||E>=f.outHeight||Math.floor(E)!==E))for(var H=0;H<y;H+=g){var P=(z+H)/k;if(!(P<0||P>=f.outWidth||Math.floor(P)!==P)){var R=I*y-1-m.get(M,E,P,A)===W*y+H?1:0;if(0!==R)C+=F.get(M,E,P,A)*R}}}T.set(C,M,D,_,A)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};var xn={kernelName:a.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,r=e.backend,i=t.x,o=n,u=o.filterSize,d=o.strides,p=o.pad,l=o.includeBatchInIndex,c=r;s(i,"MaxPoolWithArgmax");var f=c.data.get(i.dataId).values,h=a.backend_util.computePool2DInfo(i.shape,u,d,[1,1],p),m=function(e,t,n,r,i){var s=Sa(e,0,n,a.util.computeStrides(t),i,"max"),o=Fa(e,t,n,i,!0,r);return[s.values,o.values]}(f,i.shape,i.dtype,l,h),v=m[0],k=m[1],b=c.write(v,h.outShape,i.dtype),g=c.write(k,h.outShape,i.dtype);return[{dataId:b,shape:h.outShape,dtype:i.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};var Tn={kernelName:a.Mean,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,s=r.axis,o=r.keepDims,u=a.util.parseAxisParam(s,i.shape),d=a.backend_util.computeOutAndReduceShapes(i.shape,u)[1],p=a.util.sizeFromShape(d),l=[],c=n.makeTensorInfo([],"float32",new Float32Array([p]));l.push(c);var f=g({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});l.push(f);var h=Dt({inputs:{a:f,b:c},backend:n});l.push(h);var m=lt({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:o}});return l.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),m}};var Sn={kernelName:a.Min,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.axis,u=r.keepDims;s(i,"min");var d=a.util.parseAxisParam(o,i.shape),p=d,l=a.backend_util.getAxesPermutation(p,i.shape.length),c=i;null!=l&&(c=ge({inputs:{x:i},backend:n,attrs:{perm:l}}),p=a.backend_util.getInnerMostAxes(p.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("min",p,c.shape.length);for(var f=a.backend_util.computeOutAndReduceShapes(c.shape,p),h=f[0],m=f[1],v=a.util.sizeFromShape(m),k=a.util.makeZerosTypedArray(a.util.sizeFromShape(h),c.dtype),b=n.data.get(c.dataId).values,g=0;g<k.length;++g){for(var I=g*v,y=b[I],N=0;N<v;++N){var x=b[I+N];x<y&&(y=x)}k[g]=y}null!=l&&n.disposeIntermediateTensorInfo(c);var T=n.makeTensorInfo(h,c.dtype,k);if(u){var S=ea({inputs:{x:T},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(h,d)}});return n.disposeIntermediateTensorInfo(T),S}return T}};var Fn={kernelName:a.MirrorPad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.paddings,u=r.mode;s(i,"mirrorPad");for(var d=o.map((function(e,a){return e[0]+i.shape[a]+e[1]})),p=o.map((function(e){return e[0]})),l=o.map((function(e,a){return e[0]+i.shape[a]})),c="reflect"===u?0:1,f=n.data.get(i.dataId).values,h=i.shape.length,m=a.util.computeStrides(i.shape),v=a.util.sizeFromShape(d),k=d.length,b=a.util.computeStrides(d),g=a.util.getTypedArrayFromDType(i.dtype,v),I=0;I<v;I++){for(var y=a.util.indexToLoc(I,k,b),N=0;N<k;N++)y[N]<p[N]?y[N]=2*p[N]-y[N]-c:y[N]>=l[N]&&(y[N]=2*(l[N]-1)-y[N]+c);y=y.map((function(e,a){return e-p[a]}));var x=a.util.locToIndex(y,h,m);g[I]=f[x]}return{dataId:n.write(g,d,i.dtype),shape:d,dtype:i.dtype}}},Mn=l((function(e,a){var t=e%a;return e<0&&a<0||e>=0&&a>=0?t:(t+a)%a})),An=y(a.Mod,Mn),Dn={kernelName:a.Mod,backendName:"cpu",kernelFunc:An};function _n(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.logits,s=r.dim,o=i.shape.length,u=s;if(-1===u&&(u=o-1),u!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+o+" and dim was "+u);var d=a.util.parseAxisParam([u],i.shape),p=kn({inputs:{x:i},backend:n,attrs:{reductionIndices:d,keepDims:!1}}),l=a.backend_util.expandShapeToKeepDim(p.shape,d),c=ea({inputs:{x:p},backend:n,attrs:{shape:l}}),f=He({inputs:{a:i,b:c},backend:n}),h=P({inputs:{x:f},backend:n}),m=lt({inputs:{x:h},backend:n,attrs:{axis:d,keepDims:!1}}),v=ea({inputs:{x:m},backend:n,attrs:{shape:l}}),k=Dt({inputs:{a:h,b:v},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(v),k}var wn={kernelName:a.Softmax,backendName:"cpu",kernelFunc:_n};var zn={kernelName:a.Multinomial,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,o=n.logits,u=i.numSamples,d=i.seed,p=i.normalized;s(o,"multinomial");for(var l=p?o:_n({inputs:{logits:o},backend:r,attrs:{dim:-1}}),c=l.shape[0],f=l.shape[1],h=r.data.get(l.dataId).values,m=[c,u],v=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),"int32"),k=0;k<c;++k){var b=k*f,g=new Float32Array(f-1);g[0]=h[b];for(var I=1;I<g.length;++I)g[I]=g[I-1]+h[b+I];for(var y=t.alea(d.toString()),N=k*u,x=0;x<u;++x){var T=y();v[N+x]=g.length;for(var S=0;S<g.length;S++)if(T<g[S]){v[N+x]=S;break}}}return p||r.disposeIntermediateTensorInfo(l),r.makeTensorInfo(m,"int32",v)}},Cn=a.kernel_impls.nonMaxSuppressionV3Impl;var Wn={kernelName:a.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.boxes,i=a.scores,o=n.maxOutputSize,u=n.iouThreshold,d=n.scoreThreshold;s(r,"NonMaxSuppression");var p=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,c=Cn(p,l,o,u,d).selectedIndices;return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}},En=a.kernel_impls.nonMaxSuppressionV4Impl;var Hn={kernelName:a.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.boxes,i=a.scores,o=n.maxOutputSize,u=n.iouThreshold,d=n.scoreThreshold,p=n.padToMaxOutputSize;s(r,"NonMaxSuppressionPadded");var l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,f=En(l,c,o,u,d,p),h=f.selectedIndices,m=f.validOutputs;return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([m]))]}},Pn=a.kernel_impls.nonMaxSuppressionV5Impl;var Rn={kernelName:a.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.boxes,i=a.scores,o=n.maxOutputSize,u=n.iouThreshold,d=n.scoreThreshold,p=n.softNmsSigma;s(r,"NonMaxSuppressionWithScore");var l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,f=Pn(l,c,o,u,d,p),h=f.selectedIndices,m=f.selectedScores;return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([m.length],"float32",new Float32Array(m))]}};var Bn={kernelName:a.OneHot,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.indices,o=r.depth,u=r.onValue,d=r.offValue;s(i,"oneHot");var p=a.util.sizeFromShape(i.shape),l=new Float32Array(p*o);l.fill(d);for(var c=n.data.get(i.dataId).values,f=0;f<p;++f)c[f]>=0&&c[f]<o&&(l[f*o+c[f]]=u);return n.makeTensorInfo(i.shape.concat([o]),"int32",l)}};function On(e){var a=e.inputs,t=e.backend,n=a.x;if("string"===n.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===n.dtype){var r=k({inputs:{input:n},backend:t}),i=On({inputs:{x:r},backend:t}),s=Ra({inputs:{input:n},backend:t}),o=On({inputs:{x:s},backend:t}),u=c({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),u}return Wt({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var Ln={kernelName:a.ZerosLike,backendName:"cpu",kernelFunc:On};var Vn={kernelName:a.OnesLike,backendName:"cpu",kernelFunc:function e(a){var t=a.inputs,n=a.backend,r=t.x;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){var i=k({inputs:{input:r},backend:n}),s=e({inputs:{x:i},backend:n}),o=Ra({inputs:{input:r},backend:n}),u=On({inputs:{x:o},backend:n}),d=c({inputs:{real:s,imag:u},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),d}return Wt({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function qn(e){var t=e.inputs,n=e.backend,r=e.attrs.axis;if(1===t.length)return Ft({inputs:{input:t[0]},backend:n,attrs:{dim:r}});var i=t[0].shape,s=t[0].dtype;t.forEach((function(e){a.util.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),a.util.assert(s===e.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var o=[],u=Oa({inputs:t.map((function(e){var a=Ft({inputs:{input:e},backend:n,attrs:{dim:r}});return o.push(a),a})),backend:n,attrs:{axis:r}});return o.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),u}var Gn={kernelName:a.Pack,backendName:"cpu",kernelFunc:qn};var Un={kernelName:a.PadV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.paddings,u=r.constantValue;s(i,"pad");var d=o.map((function(e,a){return e[0]+i.shape[a]+e[1]})),p=o.map((function(e){return e[0]})),l=n.data.get(i.dataId).values,c=a.util.sizeFromShape(i.shape),f=i.shape.length,h=a.util.computeStrides(i.shape),m=a.util.sizeFromShape(d),v=d.length,k=a.util.computeStrides(d),b=a.util.getTypedArrayFromDType(i.dtype,m);0!==u&&b.fill(u);for(var g=0;g<c;g++){var I=a.util.indexToLoc(g,f,h).map((function(e,a){return e+p[a]}));b[a.util.locToIndex(I,v,k)]=l[g]}return{dataId:n.write(b,d,i.dtype),shape:d,dtype:i.dtype}}},Zn=l((function(e,a){return Math.pow(e,a)})),jn=y(a.Pow,Zn),Kn={kernelName:a.Pow,backendName:"cpu",kernelFunc:jn};var Yn={kernelName:a.Range,backendName:"cpu",kernelFunc:function(e){var a=e.backend,t=e.attrs,n=t.start,r=t.stop,i=t.dtype,s=xe(n,r,t.step,i);return a.makeTensorInfo([s.length],i,s)}},$n=_(a.Reciprocal,(function(e){return 1/e})),Jn={kernelName:a.Reciprocal,backendName:"cpu",kernelFunc:$n};var Qn={kernelName:a.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,o=r.alignCorners,u=r.halfPixelCenters,d=r.size;s(i,"resizeBilinear");for(var p=a.util.computeStrides(i.shape),l=d[0],c=d[1],f=i.shape,h=f[0],m=f[1],v=f[2],k=f[3],b=n.data.get(i.dataId).values,g=new Float32Array(a.util.sizeFromShape([h,l,c,k])),I=[o&&l>1?m-1:m,o&&c>1?v-1:v],y=[o&&l>1?l-1:l,o&&c>1?c-1:c],N=0,x=I[0]/y[0],T=I[1]/y[1],S=0;S<h;S++)for(var F=0;F<l;F++){var M=void 0;M=u?x*(F+.5)-.5:x*F;for(var A=Math.max(0,Math.floor(M)),D=M-A,_=Math.min(m-1,Math.ceil(M)),w=S*p[0]+A*p[1],z=S*p[0]+_*p[1],C=0;C<c;C++){var W=void 0;W=u?T*(C+.5)-.5:T*C;for(var E=Math.max(0,Math.floor(W)),H=W-E,P=Math.min(v-1,Math.ceil(W)),R=w+E*p[2],B=z+E*p[2],O=w+P*p[2],L=z+P*p[2],V=0;V<k;V++){var q=b[R+V],G=b[B+V],U=q+(b[O+V]-q)*H,Z=U+(G+(b[L+V]-G)*H-U)*D;g[N++]=Z}}}return n.makeTensorInfo([h,l,c,k],"float32",g)}};var Xn={kernelName:a.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,o=t.dy,u=r.alignCorners;s([o,i],"resizeBilinearGrad");for(var d=a.util.computeStrides(i.shape),p=i.shape,l=p[0],c=p[1],f=p[2],h=p[3],m=o.shape,v=m[1],k=m[2],b=new Float32Array(l*c*f*h),g=[u&&v>1?c-1:c,u&&k>1?f-1:f],I=[u&&v>1?v-1:v,u&&k>1?k-1:k],y=g[0]/I[0],N=g[1]/I[1],x=n.data.get(o.dataId).values,T=0,S=0;S<l;S++)for(var F=S*d[0],M=0;M<v;M++)for(var A=M*y,D=Math.floor(A),_=Math.min(Math.ceil(A),c-1),w=F+D*d[1],z=F+_*d[1],C=A-D,W=1-C,E=0;E<k;E++)for(var H=E*N,P=Math.floor(H),R=Math.min(Math.ceil(H),f-1),B=H-P,O=1-B,L=w+P*d[2],V=w+R*d[2],q=z+P*d[2],G=z+R*d[2],U=W*O,Z=W*B,j=C*O,K=C*B,Y=0;Y<h;Y++){var $=x[T++];b[L+Y]+=$*U,b[V+Y]+=$*Z,b[q+Y]+=$*j,b[G+Y]+=$*K}return n.makeTensorInfo([l,f,c,h],"float32",b)}};var er={kernelName:a.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,o=r.alignCorners,u=r.halfPixelCenters,d=r.size;s(i,"resizeNearestNeighbor");for(var p=a.util.computeStrides(i.shape),l=d[0],c=d[1],f=i.shape,h=f[0],m=f[1],v=f[2],k=f[3],b=n.data.get(i.dataId).values,g=new Float32Array(h*l*c*k),I=[o&&l>1?m-1:m,o&&c>1?v-1:v],y=[o&&l>1?l-1:l,o&&c>1?c-1:c],N=I[0]/y[0],x=I[1]/y[1],T=0,S=0;S<h;S++)for(var F=S*p[0],M=0;M<l;M++){var A=u?N*(M+.5):N*M,D=Math.min(m-1,o?Math.round(A):Math.floor(A));u&&(D=Math.max(0,D));for(var _=F+D*p[1],w=0;w<c;w++){var z=u?x*(w+.5):x*w,C=Math.min(v-1,o?Math.round(z):Math.floor(z));u&&(C=Math.max(0,C));for(var W=_+C*p[2],E=0;E<k;E++){var H=b[W+E];g[T++]=H}}}return n.makeTensorInfo([h,l,c,k],i.dtype,g)}};var ar={kernelName:a.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,o=t.dy,u=r.alignCorners;s([o,i],"resizeNearestNeighborGrad");for(var d=a.util.computeStrides(i.shape),p=a.util.computeStrides(o.shape),l=i.shape,c=l[0],f=l[1],h=l[2],m=l[3],v=o.shape,k=v[1],b=v[2],g=new Float32Array(c*f*h*m),I=n.data.get(o.dataId).values,y=[u&&k>1?f-1:f,u&&b>1?h-1:h],N=[u&&k>1?k-1:k,u&&b>1?b-1:b],x=y[0]/N[0],T=y[1]/N[1],S=1/x,F=1/T,M=2*Math.ceil(S)+2,A=2*Math.ceil(F)+2,D=0;D<c;D++)for(var _=D*d[0],w=0;w<f;w++)for(var z=_+w*d[1],C=Math.floor(w*S),W=Math.floor(C-M/2),E=0;E<h;E++)for(var H=z+E*d[2],P=Math.floor(E*F),R=Math.floor(P-A/2),B=0;B<m;B++){for(var O=0,L=0;L<M;L++){var V=L+W;if(!(V<0||V>=k)){var q=_+V*p[1],G=V*x;if(w===Math.min(f-1,u?Math.round(G):Math.floor(G)))for(var U=0;U<A;U++){var Z=U+R;if(!(Z<0||Z>=b)){var j=q+Z*p[2],K=Z*T;E===Math.min(h-1,u?Math.round(K):Math.floor(K))&&(O+=I[j+B])}}}}g[H+B]=O}return n.makeTensorInfo(i.shape,i.dtype,g)}};var tr={kernelName:a.Reverse,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.dims;s(i,"reverse");var u=i.shape.length,d=a.util.parseAxisParam(o,i.shape);if(0===u)return m({inputs:{x:i},backend:n});for(var p=new a.TensorBuffer(i.shape,i.dtype),l=n.bufferSync(i),c=function(e){var a=p.indexToLoc(e),t=a.slice();d.forEach((function(e){return t[e]=i.shape[e]-1-t[e]})),p.set.apply(p,[l.get.apply(l,t)].concat(a))},f=0;f<p.size;f++)c(f);return n.makeTensorInfo(p.shape,p.dtype,p.values)}},nr={kernelName:a.RotateWithOffset,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,n=e.attrs,r=e.backend,i=t.image,s=n,o=s.radians,u=s.fillValue,d=s.center,p=r,l=a.util.getTypedArrayFromDType(i.dtype,a.util.sizeFromShape(i.shape)),c=i.shape,f=c[0],h=c[1],m=c[2],v=c[3],k=a.backend_util.getImageCenter(d,h,m),b=k[0],g=k[1],I=Math.sin(o),y=Math.cos(o),N=p.data.get(i.dataId).values,x=0;x<f;x++)for(var T=x*m*h*v,S=0;S<h;S++)for(var F=S*(m*v),M=0;M<m;M++)for(var A=M*v,D=0;D<v;D++){var _=[f,S,M,D],w=_[2],z=_[1],C=(w-b)*y-(z-g)*I,W=(w-b)*I+(z-g)*y;C=Math.round(C+b),W=Math.round(W+g);var E=u;if("number"!=typeof u&&(E=3===D?255:u[D]),C>=0&&C<m&&W>=0&&W<h)E=N[T+W*(m*v)+C*v+D];l[T+F+A+D]=E}return{dataId:p.write(l,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},rr=_(a.Round,(function(e){var a=Math.floor(e);return e-a<.5?Math.floor(e):e-a>.5?Math.ceil(e):a%2==0?a:a+1})),ir={kernelName:a.Round,backendName:"cpu",kernelFunc:rr};function sr(e,t,n,r,i,s,o,u,d,p){var l=[r/i,i],c=e.values,f=t.values;if(0===r)return a.buffer(n,t.dtype);var h=a.buffer(l,t.dtype);h.values.fill(d);for(var m=0;m<s;m++){for(var v=[],k=0,b=0;b<o;b++){var g=c[m*o+b];v.push(g),k+=g*u[b]}if(k<0||k>=r/i)throw new Error("Invalid indices: "+v+" does not index into "+n);for(var I=0;I<i;I++)p?h.values[k*i+I]+=f[m*i+I]:h.values[k*i+I]=0===t.rank?f[0]:f[m*i+I]}return h}var or={kernelName:a.ScatterNd,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.indices,s=t.updates,o=r.shape,u=a.backend_util.calculateShapes(s,i,o),d=u.sliceRank,p=u.numUpdates,l=u.sliceSize,c=u.strides,f=u.outputSize,h=sr(n.bufferSync(i),n.bufferSync(s),o,f,l,p,d,c,0,!0);return n.makeTensorInfo(o,h.dtype,h.values)}};var ur={kernelName:a.Select,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.condition,i=t.t,o=t.e;s([r,i,o],"select");for(var u=r.shape.length,d=n.data.get(r.dataId).values,p=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values,c=a.upcastType(i.dtype,o.dtype),f=a.util.makeZerosTypedArray(a.util.sizeFromShape(i.shape),c),h=0,m=0===u||u>1||1===i.shape.length?1:a.util.sizeFromShape(i.shape.slice(1)),v=0;v<d.length;v++)for(var k=0;k<m;k++)1===d[v]?f[h++]=p[v]:f[h++]=l[v];return n.makeTensorInfo(i.shape,c,f)}},dr=a.backend_util.SELU_SCALEALPHA,pr=a.backend_util.SELU_SCALE,lr=_(a.Selu,(function(e){return e>=0?pr*e:dr*(Math.exp(e)-1)})),cr={kernelName:a.Selu,backendName:"cpu",kernelFunc:lr},fr=_(a.Sigmoid,(function(e){return 1/(1+Math.exp(-e))})),hr={kernelName:a.Sigmoid,backendName:"cpu",kernelFunc:fr},mr=_(a.Sign,(function(e){return e<0?-1:e>0?1:0})),vr={kernelName:a.Sign,backendName:"cpu",kernelFunc:mr},kr=_(a.Sin,(function(e){return Math.sin(e)})),br={kernelName:a.Sin,backendName:"cpu",kernelFunc:kr},gr=_(a.Sinh,(function(e){return Math.sinh(e)})),Ir={kernelName:a.Sinh,backendName:"cpu",kernelFunc:gr},yr=Math.log(1.1920928955078125e-7)+2,Nr=_(a.Softplus,(function(e){var a=e>-yr,t=e<yr,n=Math.exp(e);return t?n:a?e:Math.log(1+n)})),xr={kernelName:a.Softplus,backendName:"cpu",kernelFunc:Nr};var Tr={kernelName:a.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.blockShape,u=r.paddings;s([i],"spaceToBatchND");var d=a.util.sizeFromShape(o),p=[[0,0]];p.push.apply(p,u);for(var l=1+o.length;l<i.shape.length;++l)p.push([0,0]);var c=Un.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:p,constantValue:0}}),f=a.backend_util.getReshaped(c.shape,o,d,!1),h=a.backend_util.getPermuted(f.length,o.length,!1),m=a.backend_util.getReshapedPermuted(c.shape,o,d,!1),v=ea({inputs:{x:c},backend:n,attrs:{shape:f}}),k=ge({inputs:{x:v},backend:n,attrs:{perm:h}}),b=ea({inputs:{x:k},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k),b}};var Sr={kernelName:a.SparseToDense,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.sparseIndices,s=t.sparseValues,o=t.defaultValue,u=r.outputShape,d=a.backend_util.calculateShapes(s,i,u),p=d.sliceRank,l=d.numUpdates,c=d.sliceSize,f=d.strides,h=d.outputSize,m=sr(n.bufferSync(i),n.bufferSync(s),u,h,c,l,p,f,n.data.get(o.dataId).values[0],!1);return n.makeTensorInfo(u,m.dtype,m.values)}};var Fr={kernelName:a.SplitV,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,s=r.numOrSizeSplits,o=r.axis,u=a.util.parseAxisParam(o,i.shape)[0],d=a.backend_util.prepareSplitSize(i,s,u),p=new Array(i.shape.length).fill(0),l=i.shape.slice();return d.map((function(e){var a=l.slice();a[u]=e;var t=Ae({inputs:{x:i},backend:n,attrs:{begin:p,size:a}});return p[u]+=e,t}))}},Mr=_(a.Sqrt,(function(e){return Math.sqrt(e)})),Ar={kernelName:a.Sqrt,backendName:"cpu",kernelFunc:Mr},Dr={kernelName:a.Square,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=a.x,r=t;s(n,"square");for(var i=r.data.get(n.dataId).values,o=new Float32Array(i.length),u=0;u<i.length;++u){var d=i[u];o[u]=d*d}return{dataId:r.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},_r=_(a.Step,(function(e,a){var t=a;return isNaN(e)?NaN:e>0?1:t.alpha})),wr={kernelName:a.Step,backendName:"cpu",kernelFunc:_r};var zr={kernelName:a.StridedSlice,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=r.begin,u=r.end,d=r.strides,p=r.beginMask,l=r.endMask,c=r.ellipsisMask,f=r.newAxisMask,h=r.shrinkAxisMask;s(i,"stridedSlice");var m,v=a.slice_util.sliceInfo(i.shape,o,u,d,p,l,c,f,h),k=v.nonStrided,b=v.$begin,g=v.$strides,I=v.size,y=v.newShape,N=v.outShape,x=ea({inputs:{x:i},backend:n,attrs:{shape:y}});if(k){var T=Ae({inputs:{x:x},backend:n,attrs:{begin:b,size:I}});m=ea({inputs:{x:T},backend:n,attrs:{shape:N}}),n.disposeIntermediateTensorInfo(T)}else if(N.some((function(e){return 0===e})))m=n.makeTensorInfo(N,i.dtype,[]);else{var S=Ce(N,n.bufferSync(x),g,b);m=n.makeTensorInfo(S.shape,S.dtype,S.values)}var F=ea({inputs:{x:m},backend:n,attrs:{shape:N}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(m),F}},Cr=_(a.Tan,(function(e){return Math.tan(e)})),Wr={kernelName:a.Tan,backendName:"cpu",kernelFunc:Cr},Er=_(a.Tanh,(function(e){return Math.tanh(e)})),Hr={kernelName:a.Tanh,backendName:"cpu",kernelFunc:Er};var Pr={kernelName:a.Tile,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=n.reps;s(r,"tile");var o=Re(t.bufferSync(r),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}};var Rr={kernelName:a.TopK,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.x,i=n.k;n.sorted,s(r,"topk");var o=Be(t.data.get(r.dataId).values,r.shape,r.dtype,i),u=o[0],d=o[1];return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(d.shape,d.dtype,d.values)]}};var Br={kernelName:a.Transform,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,r=e.backend,i=t.image,s=t.transforms,o=n.interpolation,u=n.fillMode,d=n.fillValue,p=n.outputShape,l=i.shape,c=l[0],f=l[1],h=l[2],m=l[3],v=null!=p?p:[f,h],k=v[0],b=v[1],g=[c,k,b,m],I=a.util.computeStrides(i.shape),y=I[0],N=I[1],x=I[2],T=a.util.getTypedArrayFromDType(i.dtype,a.util.sizeFromShape(g));T.fill(d);for(var S=r.data.get(i.dataId).values,F=r.data.get(s.dataId).values,M=0;M<c;++M){for(var A=1===s.shape[0]?F:F.subarray(8*M,8*M+8),D=0;D<k;++D)for(var _=0;_<b;++_)for(var w=0;w<m;++w){var z=void 0,C=A[6]*_+A[7]*D+1;if(0!==C){var W=(A[0]*_+A[1]*D+A[2])/C,E=(A[3]*_+A[4]*D+A[5])/C,H=Or(W,h,u),P=Or(E,f,u);switch(o){case"nearest":z=Vr(S,f,h,y,N,x,M,P,H,w,d);break;case"bilinear":z=qr(S,f,h,y,N,x,M,P,H,w,d);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+o)}T[M*y+D*N+_*x+w]=z}}return r.makeTensorInfo(g,i.dtype,T)}return{dataId:r.write(T,g,i.dtype),shape:i.shape,dtype:i.dtype}}};function Or(e,t,n){switch(n){case"reflect":return function(e,t){var n=e;if(n<0){if(t<=1)n=0;else n<(r=2*t)&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1){var r;if(t<=1)n=0;else(n-=(r=2*t)*Math.trunc(n/r))>=t&&(n=r-n-1)}return a.util.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){var n=e;if(n<0)if(t<=1)n=0;else{var r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{r=t-1;n-=t*Math.trunc(n/r)}return a.util.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return a.util.clamp(0,e,t-1)}(e,t);case"constant":default:return function(e,a){return e}(e)}}function Lr(e,a,t,n,r,i,s,o,u,d,p){return 0<=o&&o<a&&0<=u&&u<t?e[s*n+o*r+u*i+d]:p}function Vr(e,a,t,n,r,i,s,o,u,d,p){return Lr(e,a,t,n,r,i,s,Math.round(o),Math.round(u),d,p)}function qr(e,a,t,n,r,i,s,o,u,d,p){var l=Math.floor(o),c=Math.floor(u),f=l+1,h=c+1;return(f-o)*((h-u)*Lr(e,a,t,n,r,i,s,l,c,d,p)+(u-c)*Lr(e,a,t,n,r,i,s,l,h,d,p))+(o-l)*((h-u)*Lr(e,a,t,n,r,i,s,f,c,d,p)+(u-c)*Lr(e,a,t,n,r,i,s,f,h,d,p))}var Gr={kernelName:a.Unique,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.attrs,n=e.backend,r=t.axis,i=a.x;s(i,"unique");var o=Oe(n.data.get(i.dataId).values,r,i.shape,i.dtype),u=o.outputValues,d=o.outputShape,p=o.indices;return[n.makeTensorInfo(d,i.dtype,u),n.makeTensorInfo([p.length],"int32",p)]}};var Ur={kernelName:a.Unpack,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,n=e.attrs,r=a.value,i=n.axis;i<0&&(i+=r.shape.length);for(var s=r.shape.length,o=r.shape[i],u=new Array(s-1),d=0,p=0;p<s;p++)p!==i&&(u[d++]=r.shape[p]);var l=new Array(s).fill(0),c=r.shape.slice();c[i]=1;var f=new Array(o);for(p=0;p<f.length;p++){l[i]=p;var h=Ae({inputs:{x:r},backend:t,attrs:{begin:l,size:c}});f[p]=ea({inputs:{x:h},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(h)}return f}};for(var Zr={kernelName:a.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,o=t.segmentIds,u=r.numSegments;s(i,"unsortedSegmentSum");for(var d=[],p=[],l=i.shape.length-o.shape.length,c=o,f=0;f<l;++f){var h=Ft({inputs:{input:c},backend:n,attrs:{dim:f+1}});c=h,p.push(h)}for(f=0;f<u;++f){var m=a.util.createScalarValue(f,"int32"),v=n.makeTensorInfo([],"int32",m),k=vt({inputs:{a:v,b:c},backend:n}),b=g({inputs:{x:k},backend:n,attrs:{dtype:"float32"}}),I=le({inputs:{a:b,b:i},backend:n}),y=lt({inputs:{x:I},backend:n,attrs:{axis:0,keepDims:!1}});d.push(y),p.push(v),p.push(k),p.push(b),p.push(I),p.push(y)}var N=qn({inputs:d,backend:n,attrs:{axis:0}});return p.forEach((function(e){return n.disposeIntermediateTensorInfo(e)})),N}},jr=0,Kr=[ra,p,sa,ua,F,da,pa,la,ca,fa,ma,ka,ga,Na,Ta,Aa,Da,_a,wa,na,za,Ca,Wa,I,W,Ha,f,Pa,La,Ga,Ua,qa,ja,Ka,Za,$a,Qa,Xa,et,at,tt,rt,it,st,ot,ut,pt,dt,_t,ft,qe,ht,kt,St,R,Mt,L,Ct,Et,Ht,G,Bt,Ot,Lt,Vt,qt,K,Zt,v,jt,Ba,Yt,Jt,Xt,Ue,J,tn,nn,ae,sn,dn,ln,hn,mn,vn,ie,gn,In,yn,Nn,xn,bn,Tn,Sn,ue,Fn,Dn,zn,ce,he,Wn,Hn,Rn,ke,Bn,Vn,Gn,Un,Kn,Ke,Ne,Yn,b,Jn,$e,Qe,aa,Qn,Xn,er,ar,tr,nr,ir,Fe,or,ur,cr,hr,vr,br,Ir,De,wn,xr,Tr,Sr,Fr,Ar,Dr,ze,wr,zr,Pe,ct,Wr,Hr,Pr,Rr,Ie,Br,Gr,Ur,Zr,Ln];jr<Kr.length;jr++){var Yr=Kr[jr];a.registerKernel(Yr)}e.MathBackendCPU=u,e.shared=Le,e.version_cpu="3.4.0",Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-cpu.min.js.map
