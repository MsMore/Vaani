/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import{util as e,clone as t,env as a,scalar as n,keep as s,tensor as r,stack as o,concat as p,unstack as i,tidy as m,reshape as u,slice as d,io as c,Tensor as y}from"@tensorflow/tfjs-core";import{squaredDifference as l,pow as h,maximum as f,minimum as N,sub as g,floorDiv as b,divNoNan as x,div as T,mul as _,mod as S,addN as O,add as w,isNaN as A,prelu as E,leakyRelu as v,prod as I,rsqrt as D,relu6 as k,clipByValue as M,tan as V,tanh as z,square as C,sqrt as L,softplus as F,sinh as $,sign as R,sin as j,sigmoid as P,selu as B,round as H,relu as W,real as q,reciprocal as U,neg as G,imag as Q,log1p as K,log as X,floor as Z,expm1 as Y,exp as J,erf as ee,elu as te,cosh as ae,cos as ne,complex as se,ceil as re,atanh as oe,atan2 as pe,atan as ie,asinh as me,asin as ue,acosh as de,acos as ce,abs as ye,dilation2d as le,maxPool3d as he,avgPool3d as fe,maxPoolWithArgmax as Ne,maxPool as ge,avgPool as be,conv3d as xe,depthwiseConv2d as Te,conv2dTranspose as _e,fused as Se,conv2d as Oe,conv1d as we,zerosLike as Ae,zeros as Ee,truncatedNormal as ve,range as Ie,randomUniform as De,onesLike as ke,ones as Me,oneHot as Ve,multinomial as ze,linspace as Ce,fill as Le,setdiff1dAsync as Fe,cast as $e,whereAsync as Re,image as je,unique as Pe,topk as Be,scalar as He,tensor1d as We,where as qe,logicalOr as Ue,logicalNot as Ge,logicalAnd as Qe,lessEqual as Ke,less as Xe,greaterEqual as Ze,greater as Ye,notEqual as Je,equal as et,transpose as tt,einsum as at,matMul as nt,sparseToDense as st,logSoftmax as rt,softmax as ot,localResponseNormalization as pt,batchNorm as it,denseBincount as mt,bincount as ut,cumsum as dt,argMin as ct,argMax as yt,any as lt,all as ht,sum as ft,min as Nt,mean as gt,max as bt,gatherND as xt,scatterND as Tt,split as _t,tile as St,unstack as Ot,squeeze as wt,reshape as At,stack as Et,stridedSlice as vt,slice as It,reverse as Dt,gather as kt,concat as Mt,irfft as Vt,rfft as zt,ifft as Ct,fft as Lt,broadcastTo as Ft,depthToSpace as $t,batchToSpaceND as Rt,spaceToBatchND as jt,pad as Pt,mirrorPad as Bt,expandDims as Ht}from"@tensorflow/tfjs-core/dist/ops/ops_for_converter";var Wt,qt;!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(Wt||(Wt={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(qt||(qt={}));const Ut={};function Gt(e,t){const a={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};Ut[e]=a}function Qt(e){return Ut[e]}function Kt(e){delete Ut[e]}function Xt(t,a,n,s,r){const o=a.inputParams[t];if(o&&void 0!==o.inputIndexStart){const t=o.inputIndexStart,p=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?t+1:o.inputIndexEnd;if("tensor"===o.type)return Zt(a.inputNames[o.inputIndexStart],n,s,r);if("tensors"===o.type){return a.inputNames.slice(t,p).map((e=>Zt(e,n,s,r)))}const i=Zt(a.inputNames.slice(t)[0],n,s,r),m=i.dataSync();return"number"===o.type?m[0]:e.toNestedArray(i.shape,m)}const p=a.attrParams[t];return p&&p.value}function Zt(e,t,a,n){const[s,r]=ea(e);if(null!=n){const e=n.getHashTableHandleByName(s);if(null!=e)return e}const o=a.currentContextIds.find((e=>!!t[Jt(s,e)]));return void 0!==o?t[Jt(s,o)][r]:void 0}function Yt(e,t){const[a,n]=ea(e);return[Jt(a,t&&t.currentContextId),n]}function Jt(e,t){return t?`${e}-${t}`:e}function ea(e){const t=e.split(":");if(1===t.length)return[e,0];return[t[0],Number(t[t.length-1])]}function ta(e,t,a){let n=Xt("pad",e,t,a);if("explicit"===n){n=Xt("explicitPaddings",e,t,a);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=n[2*e],s[e][1]=n[2*e+1];return s}return n}function aa(e){return e.kept?e:t(e)}var na=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var sa=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var ra=Object.freeze({__proto__:null,json:[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]});var oa=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var pa=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var ia=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var ma=Object.freeze({__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});var ua=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var da=Object.freeze({__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}]});var ca=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]});var ya=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var la=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}]});var ha=Object.freeze({__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]});var fa=Object.freeze({__proto__:null,json:[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var Na=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]});var ga=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var ba=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]});class xa{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[na,sa,ra,oa,pa,ia,ma,ya,ca,ua,la,ha,fa,Na,ga,ba,da].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const a=e.node,n=[],s=[],r=[],o=a.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||r.push(e[t.name]),e)),{});let p=[];const i=[];let m={},u={};null!=t&&(m=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach((e=>{const t=o[e];t.inputNames.forEach((e=>{const[a]=Yt(e);t.inputs.push(o[a]),o[a].children.push(t)}))})),0===Object.keys(u).length?d.forEach((e=>{const t=o[e];0===t.children.length&&i.push(t)})):Object.keys(u).forEach((e=>{const[t]=Yt(e),a=o[t];null!=a&&(a.signatureKey=u[e],i.push(a))})),Object.keys(m).length>0?Object.keys(m).forEach((e=>{const[t]=Yt(e),a=o[t];a&&(a.signatureKey=m[e],p.push(a))})):p=n;let c={};null!=e.library&&null!=e.library.function&&(c=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const y={nodes:o,inputs:p,outputs:i,weights:s,placeholders:n,signature:t,functions:c};return r.length>0&&(y.initNodes=r),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,a)=>(t[e[a].name]=a,t)),{})}mapNode(e){const t=Qt(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.substr(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return null!=t.inputs&&(a.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(a.attrParams=t.attrs.reduce(((t,a)=>{const n=a.type;let s;switch(a.type){case"string":s=_a(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=_a(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":s=Ma(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ma(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":s=Oa(e.attr,a.tfName,a.defaultValue||0),void 0===s&&a.tfDeprecatedName&&(s=Oa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":s=ka(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=ka(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":s=Sa(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Sa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":s=za(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=za(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":s=Da(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Da(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":s=Va(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Va(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":s=Ea(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ea(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":s=va(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=va(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":s=Aa(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Aa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return t[a.name]={value:s,type:n},t}),{})),a}mapFunction(e){const t=e.nodeDef,a=[];let n={};null!=t&&(n=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&a.push(e[t.name]),e)),{}));const s=[],r=[];e.signature.inputArg.forEach((e=>{const[t]=Yt(e.name),a={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:wa(e.type),type:"dtype"}},children:[]};a.signatureKey=e.name,s.push(a),n[t]=a}));Object.keys(n).forEach((e=>{const t=n[e];t.inputNames.forEach((e=>{const[a]=Yt(e);t.inputs.push(n[a]),n[a].children.push(t)}))}));const o=e.ret;e.signature.outputArg.forEach((e=>{const[t,a]=Yt(o[e.name]),s=n[t];null!=s&&(s.defaultOutput=a,r.push(s))}));const p=this.mapArgsToSignature(e);return{nodes:n,inputs:s,outputs:r,weights:a,placeholders:[],signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let a=e.name;return null!=t&&(a=t[a]),{name:a,dtype:e.type}}}function Ta(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=a().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function _a(e,t,a,n=!1){const s=e[t];return null!=s?Ta(s.s,n):a}function Sa(e,t,a){const n=e[t];return n?n.b:a}function Oa(e,t,a){const n=e[t]||{},s=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof s?s:parseInt(s,10)}function wa(e){switch("string"==typeof e&&(e=Wt[e]),e){case Wt.DT_FLOAT:return"float32";case Wt.DT_INT32:case Wt.DT_INT64:case Wt.DT_INT8:case Wt.DT_UINT8:return"int32";case Wt.DT_BOOL:return"bool";case Wt.DT_DOUBLE:return"float32";case Wt.DT_STRING:return"string";default:return null}}function Aa(e,t,a){const n=e[t];return n&&n.func?n.func.name:a}function Ea(e,t,a){const n=e[t];return n&&n.type?wa(n.type):a}function va(e,t,a){const n=e[t];return n&&n.list&&n.list.type?n.list.type.map((e=>wa(e))):a}function Ia(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function Da(e,t,a){const n=e[t];return n&&n.shape?Ia(n.shape):a}function ka(e,t,a){const n=e[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):a}function Ma(e,t,a,n=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>Ta(e,n))):a}function Va(e,t,a){const n=e[t];return n&&n.list&&n.list.shape?n.list.shape.map((e=>Ia(e))):a}function za(e,t,a){const n=e[t];return n&&n.list&&n.list.b?n.list.b:a}class Ca{constructor(e,t,a){this.node=e,this.tensorMap=t,this.context=a,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Zt(e,this.tensorMap,this.context)}getAttr(e,t){const a=this.node.rawAttrs[e];if(null!=a.tensor)return Zt(e,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return Oa(this.node.rawAttrs,e,t);if(null!=a.s)return _a(this.node.rawAttrs,e,t);if(null!=a.b)return Sa(this.node.rawAttrs,e,t);if(null!=a.shape)return Da(this.node.rawAttrs,e,t);if(null!=a.type)return Ea(this.node.rawAttrs,e,t);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return ka(this.node.rawAttrs,e,t);if(null!=a.list.s)return Ma(this.node.rawAttrs,e,t);if(null!=a.list.shape)return Va(this.node.rawAttrs,e,t);if(null!=a.list.b)return za(this.node.rawAttrs,e,t);if(null!=a.list.type)return va(this.node.rawAttrs,e,t)}return t}}function La(t,a,n=""){if("number"!=typeof t&&"number"!=typeof a){e.assert(t.length===a.length,(()=>n+` Shapes ${t} and ${a} must match`));for(let s=0;s<t.length;s++){const r=t[s],o=a[s];e.assert(r<0||o<0||r===o,(()=>n+` Shapes ${t} and ${a} must match`))}}}function Fa(e){return"number"!=typeof e&&!e.some((e=>e<0))}function $a(e,t,a){let n=Ra(e,a);const s=!Fa(n);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(s&&t.forEach((e=>{n=Ra(e.shape,n)})),!Fa(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function Ra(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const a=[];for(let n=0;n<e.length;++n){const s=e[n],r=t[n];if(s>=0&&r>=0&&s!==r)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);a[n]=s>=0?s:r}return a}class ja{constructor(e,t,a,r,o,p,i){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=p,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=n(0),s(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),La(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);a.tensor=t,s(t),a.written=!0,this.tensors[e]=a}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,a)=>this.write(e,t[a])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return r([],[0].concat(this.elementShape));const a=this.readMany(e);return La(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),o(a,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return r([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const a=this.readMany(t);return La(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),p(a,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const a=Math.max(...e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(e,i(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let a=0;const n=e.map((e=>(a+=e,a)));if(a!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===a?0:t.size/a,r=[];m((()=>{t=u(t,[1,a,s]);for(let a=0;a<e.length;++a){const o=[0,0===a?0:n[a-1],0],p=[1,e[a],s];r[a]=u(d(t,o,p),this.elementShape)}return r}));const o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,r)}}class Pa{constructor(e,t,a,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=a,null!=e&&e.forEach((e=>{if(a!==e.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${e.dtype}`);La(t,e.shape,"TensorList shape mismatch: "),s(e)})),this.idTensor=n(0),this.maxNumElements=r,s(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Pa([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,a=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);La(e,this.elementShape,"TensorList shape mismatch: ");const n=$a(this.elementShape,this.tensors,e);return m((()=>{const e=this.tensors.map((e=>u(e,n)));return o(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const a=$a(this.elementShape,this.tensors,e),n=this.tensors.pop();return La(n.shape,e,"TensorList shape mismatch: "),u(n,a)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(La(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");s(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);La(this.tensors[e].shape,t,"TensorList shape mismatch: ");const n=$a(this.elementShape,this.tensors,t);return u(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);La(this.elementShape,t.shape,"TensorList shape mismatch: "),s(t),this.tensors[e]=t}gather(e,t,a){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);La(this.elementShape,a,"TensorList shape mismatch: "),e=e.slice(0,this.size());const n=$a(this.elementShape,this.tensors,a);return 0===e.length?r([],[0].concat(n)):m((()=>{const t=e.map((e=>u(this.tensors[e],n)));return o(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);La(this.elementShape,t,"TensorList shape mismatch: ");const a=$a(this.elementShape,this.tensors,t);return 0===this.size()?r([],[0].concat(a)):m((()=>{const e=this.tensors.map((e=>u(e,a)));return p(e,0)}))}}const Ba=async(e,t,a)=>{switch(e.op){case"If":case"StatelessIf":{const n=Xt("thenBranch",e,t,a),s=Xt("elseBranch",e,t,a),r=Xt("cond",e,t,a),o=Xt("args",e,t,a);return(await r.data())[0]?a.functionMap[n].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap):a.functionMap[s].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{const n=Xt("body",e,t,a),s=Xt("cond",e,t,a),r=Xt("args",e,t,a),o=await a.functionMap[s].executeFunctionAsync(r,a.tensorArrayMap,a.tensorListMap),p=r.map((e=>e.id));let i=await o[0].data();o.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||e.dispose()}));let m=r;for(;i[0];){const e=m;m=await a.functionMap[n].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);const t=m.map((e=>e.id));e.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const r=await a.functionMap[s].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);i=await r[0].data(),r.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return m}case"LoopCond":return[aa(Xt("pred",e,t,a))];case"Switch":{const n=Xt("pred",e,t,a);let s=Xt("data",e,t,a);return s.kept||(s=aa(s)),(await n.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const n=e.inputNames.find((e=>void 0!==Zt(e,t,a)));if(n){return[aa(Zt(n,t,a))]}return}case"Enter":{const n=Xt("frameName",e,t,a),s=Xt("tensor",e,t,a);return a.enterFrame(n),[aa(s)]}case"Exit":{const n=Xt("tensor",e,t,a);return a.exitFrame(),[aa(n)]}case"NextIteration":{const n=Xt("tensor",e,t,a);return a.nextIteration(),[aa(n)]}case"TensorArrayV3":{const s=Xt("size",e,t,a),r=Xt("dtype",e,t,a),o=Xt("elementShape",e,t,a),p=Xt("dynamicSize",e,t,a),i=Xt("clearAfterRead",e,t,a),m=Xt("identicalElementShapes",e,t,a),u=Xt("name",e,t,a),d=new ja(u,r,s,o,m,p,i);return a.addTensorArray(d),[d.idTensor,n(1)]}case"TensorArrayWriteV3":{const n=Xt("tensorArrayId",e,t,a),s=Xt("index",e,t,a),r=Xt("tensor",e,t,a),o=a.getTensorArray(n.id);return o.write(s,r),[o.idTensor]}case"TensorArrayReadV3":{const n=Xt("tensorArrayId",e,t,a),s=Xt("index",e,t,a);return[a.getTensorArray(n.id).read(s)]}case"TensorArrayGatherV3":{const n=Xt("tensorArrayId",e,t,a),s=Xt("indices",e,t,a),r=Xt("dtype",e,t,a);return[a.getTensorArray(n.id).gather(s,r)]}case"TensorArrayScatterV3":{const n=Xt("tensorArrayId",e,t,a),s=Xt("indices",e,t,a),r=Xt("tensor",e,t,a),o=a.getTensorArray(n.id);return o.scatter(s,r),[o.idTensor]}case"TensorArrayConcatV3":{const n=Xt("tensorArrayId",e,t,a),s=a.getTensorArray(n.id),r=Xt("dtype",e,t,a);return[s.concat(r)]}case"TensorArraySplitV3":{const n=Xt("tensorArrayId",e,t,a),s=Xt("tensor",e,t,a),r=Xt("lengths",e,t,a),o=a.getTensorArray(n.id);return o.split(r,s),[o.idTensor]}case"TensorArraySizeV3":{const s=Xt("tensorArrayId",e,t,a),r=a.getTensorArray(s.id);return[n(r.size(),"int32")]}case"TensorArrayCloseV3":{const n=Xt("tensorArrayId",e,t,a),s=a.getTensorArray(n.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const n=Xt("tensorListId",e,t,a),s=Xt("index",e,t,a),r=Xt("tensor",e,t,a),o=a.getTensorList(n.id);return o.setItem(s,r),[o.idTensor]}case"TensorListGetItem":{const n=Xt("tensorListId",e,t,a),s=Xt("index",e,t,a),r=Xt("elementShape",e,t,a),o=Xt("elementDType",e,t,a);return[a.getTensorList(n.id).getItem(s,r,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=Xt("indices",e,t,a),s=function(e,t,a,n){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=n&&-1!==n&&s>=n)throw new Error(`Max index must be < array size (${s}  vs. ${n})`);const r=new Pa([],a,e.dtype,n),o=i(e,0);return t.forEach(((e,t)=>{r.setItem(e,o[t])})),r}(Xt("tensor",e,t,a),n,Xt("elementShape",e,t,a),Xt("numElements",e,t,a));return a.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=Xt("elementShape",e,t,a),s=Xt("elementDType",e,t,a);let r;r="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=function(e,t,a){return new Pa([],e,t,a)}(n,s,Xt(r,e,t,a));return a.addTensorList(o),[o.idTensor]}case"TensorListGather":{const n=Xt("tensorListId",e,t,a),s=Xt("indices",e,t,a),r=Xt("elementShape",e,t,a),o=Xt("elementDType",e,t,a);return[a.getTensorList(n.id).gather(s,o,r)]}case"TensorListStack":{const n=Xt("tensorListId",e,t,a),s=Xt("elementShape",e,t,a),r=Xt("elementDType",e,t,a),o=Xt("numElements",e,t,a);return[a.getTensorList(n.id).stack(s,r,o)]}case"TensorListFromTensor":{const n=function(e,t,a){const n=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==a)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${a}`);La(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=i(e);return new Pa(s,t,n)}(Xt("tensor",e,t,a),Xt("elementShape",e,t,a),Xt("elementDType",e,t,a));return a.addTensorList(n),[n.idTensor]}case"TensorListConcat":{const n=Xt("tensorListId",e,t,a),s=a.getTensorList(n.id),r=Xt("dtype",e,t,a),o=Xt("elementShape",e,t,a);return[s.concat(r,o)]}case"TensorListPushBack":{const n=Xt("tensorListId",e,t,a),s=Xt("tensor",e,t,a),r=a.getTensorList(n.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const n=Xt("tensorListId",e,t,a),s=Xt("elementShape",e,t,a),r=Xt("elementDType",e,t,a);return[a.getTensorList(n.id).popBack(s,r)]}case"TensorListSplit":{const n=Xt("tensor",e,t,a),s=Xt("elementShape",e,t,a),r=function(e,t,a){let n=0;const s=t.map((e=>(n+=e,n)));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);const r=Ra(e.shape.slice(1),a),o=0===n?0:e.size/n,p=m((()=>{const a=[];e=u(e,[1,n,o]);for(let n=0;n<t.length;++n){const p=[0,0===n?0:s[n-1],0],i=[1,t[n],o];a[n]=u(d(e,p,i),r)}return e.dispose(),a})),i=new Pa([],a,e.dtype,t.length);for(let e=0;e<p.length;e++)i.setItem(e,p[e]);return i}(n,Xt("lengths",e,t,a),s);return a.addTensorList(r),[r.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ha(e,t,a){const[n,s]=Xt("fusedOps",e,t,a),r="biasadd"===n,o="prelu"===s,p="fusedbatchnorm"===n,i=Xt("numArgs",e,t,a);if(r){if(o&&2!==i)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(p)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const m=Xt("strides",e,t,a),u=ta(e,t,a),d=Xt("dataFormat",e,t,a).toUpperCase(),c=Xt("dilations",e,t,a),[y,l]=Xt("args",e,t,a);return{stride:m,pad:u,dataFormat:d,dilations:c,biasArg:y,preluArg:l,activationFunc:s,leakyreluAlpha:Xt("leakyreluAlpha",e,t,a)}}function Wa(e,t,a){return{boxes:Xt("boxes",e,t,a),scores:Xt("scores",e,t,a),maxOutputSize:Xt("maxOutputSize",e,t,a),iouThreshold:Xt("iouThreshold",e,t,a),scoreThreshold:Xt("scoreThreshold",e,t,a),softNmsSigma:Xt("softNmsSigma",e,t,a)}}class qa{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=n(0),this.tensorMap=new Map,s(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return He(this.size(),"int32")}async import(t,a){this.checkKeyAndValueTensor(t,a);const n=await t.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),m((()=>{const t=i(a),r=n.length,o=t.length;e.assert(r===o,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${o} elements.`));for(let e=0;e<r;e++){const a=n[e],r=t[e];s(r),this.tensorMap.set(a,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const a=await e.data();return m((()=>{const e=[];for(let n=0;n<a.length;n++){const s=a[n],r=this.findWithDefault(s,t);e.push(r)}return o(e)}))}findWithDefault(e,t){const a=this.tensorMap.get(e);return null!=a?a:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function Ua(t,a,n,s){const r=((t,a,n)=>{switch(t.category){case"arithmetic":return m((()=>((e,t,a)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[w(Xt("a",e,t,a),Xt("b",e,t,a))];case"AddN":return[O(Xt("tensors",e,t,a))];case"FloorMod":case"Mod":return[S(Xt("a",e,t,a),Xt("b",e,t,a))];case"Mul":return[_(Xt("a",e,t,a),Xt("b",e,t,a))];case"RealDiv":case"Div":return[T(Xt("a",e,t,a),Xt("b",e,t,a))];case"DivNoNan":return[x(Xt("a",e,t,a),Xt("b",e,t,a))];case"FloorDiv":return[b(Xt("a",e,t,a),Xt("b",e,t,a))];case"Sub":return[g(Xt("a",e,t,a),Xt("b",e,t,a))];case"Minimum":return[N(Xt("a",e,t,a),Xt("b",e,t,a))];case"Maximum":return[f(Xt("a",e,t,a),Xt("b",e,t,a))];case"Pow":return[h(Xt("a",e,t,a),Xt("b",e,t,a))];case"SquaredDifference":return[l(Xt("a",e,t,a),Xt("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"basic_math":return m((()=>((e,t,a)=>{switch(e.op){case"Abs":case"ComplexAbs":return[ye(Xt("x",e,t,a))];case"Acos":return[ce(Xt("x",e,t,a))];case"Acosh":return[de(Xt("x",e,t,a))];case"Asin":return[ue(Xt("x",e,t,a))];case"Asinh":return[me(Xt("x",e,t,a))];case"Atan":return[ie(Xt("x",e,t,a))];case"Atan2":return[pe(Xt("x",e,t,a),Xt("y",e,t,a))];case"Atanh":return[oe(Xt("x",e,t,a))];case"Ceil":return[re(Xt("x",e,t,a))];case"Complex":return[se(Xt("real",e,t,a),Xt("imag",e,t,a))];case"Cos":return[ne(Xt("x",e,t,a))];case"Cosh":return[ae(Xt("x",e,t,a))];case"Elu":return[te(Xt("x",e,t,a))];case"Erf":return[ee(Xt("x",e,t,a))];case"Exp":return[J(Xt("x",e,t,a))];case"Expm1":return[Y(Xt("x",e,t,a))];case"Floor":return[Z(Xt("x",e,t,a))];case"Log":return[X(Xt("x",e,t,a))];case"Log1p":return[K(Xt("x",e,t,a))];case"Imag":return[Q(Xt("x",e,t,a))];case"Neg":return[G(Xt("x",e,t,a))];case"Reciprocal":return[U(Xt("x",e,t,a))];case"Real":return[q(Xt("x",e,t,a))];case"Relu":return[W(Xt("x",e,t,a))];case"Round":return[H(Xt("x",e,t,a))];case"Selu":return[B(Xt("x",e,t,a))];case"Sigmoid":return[P(Xt("x",e,t,a))];case"Sin":return[j(Xt("x",e,t,a))];case"Sign":return[R(Xt("x",e,t,a))];case"Sinh":return[$(Xt("x",e,t,a))];case"Softplus":return[F(Xt("x",e,t,a))];case"Sqrt":return[L(Xt("x",e,t,a))];case"Square":return[C(Xt("x",e,t,a))];case"Tanh":return[z(Xt("x",e,t,a))];case"Tan":return[V(Xt("x",e,t,a))];case"ClipByValue":return[M(Xt("x",e,t,a),Xt("clipValueMin",e,t,a),Xt("clipValueMax",e,t,a))];case"Relu6":return[k(Xt("x",e,t,a))];case"Rsqrt":return[D(Zt(e.inputNames[0],t,a))];case"Prod":return[I(Xt("x",e,t,a),Xt("axes",e,t,a))];case"LeakyRelu":return[v(Xt("x",e,t,a),Xt("alpha",e,t,a))];case"Prelu":return[E(Xt("x",e,t,a),Xt("alpha",e,t,a))];case"IsNan":return[A(Zt(e.inputNames[0],t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"control":return Ba(t,a,n);case"convolution":return m((()=>((e,t,a)=>{switch(e.op){case"Conv1D":{const n=Xt("stride",e,t,a),s=Xt("pad",e,t,a),r=Xt("dataFormat",e,t,a).toUpperCase(),o=Xt("dilation",e,t,a);return[we(Xt("x",e,t,a),Xt("filter",e,t,a),n,s,r,o)]}case"Conv2D":{const n=Xt("strides",e,t,a),s=ta(e,t,a),r=Xt("dataFormat",e,t,a).toUpperCase(),o=Xt("dilations",e,t,a);return[Oe(Xt("x",e,t,a),Xt("filter",e,t,a),[n[1],n[2]],s,r,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:n,pad:s,dataFormat:r,dilations:o,biasArg:p,preluArg:i,activationFunc:m,leakyreluAlpha:u}=Ha(e,t,a);return[Se.conv2d({x:Xt("x",e,t,a),filter:Xt("filter",e,t,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[o[1],o[2]],bias:p,activation:m,preluActivationWeights:i,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:s,dataFormat:r,dilations:o,biasArg:p,preluArg:i,activationFunc:m,leakyreluAlpha:u}=Ha(e,t,a);return[Se.depthwiseConv2d({x:Xt("x",e,t,a),filter:Xt("filter",e,t,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[o[1],o[2]],bias:p,activation:m,preluActivationWeights:i,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=Xt("outputShape",e,t,a),s=Xt("strides",e,t,a),r=ta(e,t,a);return[_e(Xt("x",e,t,a),Xt("filter",e,t,a),n,[s[1],s[2]],r)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=Xt("strides",e,t,a),s=ta(e,t,a),r=Xt("dilations",e,t,a),o=Xt("dataFormat",e,t,a).toUpperCase();return[Te(Xt("input",e,t,a),Xt("filter",e,t,a),[n[1],n[2]],s,o,[r[1],r[2]])]}case"Conv3D":{const n=Xt("strides",e,t,a),s=Xt("pad",e,t,a),r=Xt("dataFormat",e,t,a).toUpperCase(),o=Xt("dilations",e,t,a);return[xe(Xt("x",e,t,a),Xt("filter",e,t,a),[n[1],n[2],n[3]],s,r,[o[1],o[2],o[3]])]}case"AvgPool":{const n=Xt("strides",e,t,a),s=Xt("pad",e,t,a),r=Xt("kernelSize",e,t,a);return[be(Xt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPool":{const n=Xt("strides",e,t,a),s=Xt("pad",e,t,a),r=Xt("kernelSize",e,t,a);return[ge(Xt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{const n=Xt("strides",e,t,a),s=Xt("pad",e,t,a),r=Xt("kernelSize",e,t,a),o=Xt("includeBatchInIndex",e,t,a),{result:p,indexes:i}=Ne(Xt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s,o);return[p,i]}case"AvgPool3D":{const n=Xt("strides",e,t,a),s=Xt("pad",e,t,a),r=Xt("kernelSize",e,t,a);return[fe(Xt("x",e,t,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{const n=Xt("strides",e,t,a),s=Xt("pad",e,t,a),r=Xt("kernelSize",e,t,a);return[he(Xt("x",e,t,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{const n=Xt("strides",e,t,a),s=Xt("pad",e,t,a),r=Xt("dilations",e,t,a),o=n[1],p=n[2],i=r[1],m=r[2];return[le(Xt("x",e,t,a),Xt("filter",e,t,a),[o,p],s,[i,m],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"creation":return m((()=>((e,t,a)=>{switch(e.op){case"Fill":{const n=Xt("shape",e,t,a),s=Xt("dtype",e,t,a),r=Xt("value",e,t,a);return[Le(n,r,s)]}case"LinSpace":{const n=Xt("start",e,t,a),s=Xt("stop",e,t,a),r=Xt("num",e,t,a);return[Ce(n,s,r)]}case"Multinomial":{const n=Xt("logits",e,t,a),s=Xt("numSamples",e,t,a),r=Xt("seed",e,t,a);return[ze(n,s,r)]}case"OneHot":{const n=Xt("indices",e,t,a),s=Xt("depth",e,t,a),r=Xt("onValue",e,t,a),o=Xt("offValue",e,t,a);return[Ve(n,s,r,o)]}case"Ones":return[Me(Xt("shape",e,t,a),Xt("dtype",e,t,a))];case"OnesLike":return[ke(Xt("x",e,t,a))];case"RandomUniform":return[De(Xt("shape",e,t,a),Xt("minval",e,t,a),Xt("maxval",e,t,a),Xt("dtype",e,t,a))];case"Range":{const n=Xt("start",e,t,a),s=Xt("stop",e,t,a),r=Xt("step",e,t,a);return[Ie(n,s,r,Xt("dtype",e,t,a))]}case"TruncatedNormal":{const n=Xt("shape",e,t,a),s=Xt("mean",e,t,a),r=Xt("stdDev",e,t,a),o=Xt("seed",e,t,a);return[ve(n,s,r,Xt("dtype",e,t,a),o)]}case"Zeros":return[Ee(Xt("shape",e,t,a),Xt("dtype",e,t,a))];case"ZerosLike":return[Ae(Xt("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"dynamic":return(async(e,t,a)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p,softNmsSigma:i}=Wa(e,t,a),m=await je.nonMaxSuppressionWithScoreAsync(n,s,r,o,p,i);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p}=Wa(e,t,a),i=Xt("padToMaxOutputSize",e,t,a),m=await je.nonMaxSuppressionPaddedAsync(n,s,r,o,p,i);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p}=Wa(e,t,a);return[await je.nonMaxSuppressionAsync(n,s,r,o,p)]}case"Where":{const n=$e(Xt("condition",e,t,a),"bool"),s=[await Re(n)];return n.dispose(),s}case"ListDiff":return Fe(Xt("x",e,t,a),Xt("y",e,t,a));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n);case"evaluation":return m((()=>((e,t,a)=>{switch(e.op){case"TopKV2":{const n=Xt("x",e,t,a),s=Xt("k",e,t,a),r=Xt("sorted",e,t,a),o=Be(n,s,r);return[o.values,o.indices]}case"Unique":{const n=Xt("x",e,t,a),s=Pe(n);return[s.values,s.indices]}case"UniqueV2":{const n=Xt("x",e,t,a),s=Xt("axis",e,t,a),r=Pe(n,s);return[r.values,r.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"image":return m((()=>((e,t,a)=>{switch(e.op){case"ResizeBilinear":{const n=Xt("images",e,t,a),s=Xt("size",e,t,a),r=Xt("alignCorners",e,t,a),o=Xt("halfPixelCenters",e,t,a);return[je.resizeBilinear(n,[s[0],s[1]],r,o)]}case"ResizeNearestNeighbor":{const n=Xt("images",e,t,a),s=Xt("size",e,t,a),r=Xt("alignCorners",e,t,a),o=Xt("halfPixelCenters",e,t,a);return[je.resizeNearestNeighbor(n,[s[0],s[1]],r,o)]}case"CropAndResize":{const n=Xt("image",e,t,a),s=Xt("boxes",e,t,a),r=Xt("boxInd",e,t,a),o=Xt("cropSize",e,t,a),p=Xt("method",e,t,a),i=Xt("extrapolationValue",e,t,a);return[je.cropAndResize(n,s,r,o,p,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"graph":return m((()=>((e,t,a)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const n=Xt("default",e,t,a);return[Zt(e.name,t,a)||n];case"Placeholder":return[Zt(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[aa(Xt("x",e,t,a))];case"IdentityN":return Xt("x",e,t,a).map((e=>aa(e)));case"Snapshot":return[aa(Xt("x",e,t,a))];case"Shape":return[We(Xt("x",e,t,a).shape,"int32")];case"ShapeN":return Xt("x",e,t,a).map((e=>We(e.shape)));case"Size":return[He(Xt("x",e,t,a).size,"int32")];case"Rank":return[He(Xt("x",e,t,a).rank,"int32")];case"NoOp":return[He(1)];case"Print":const s=Xt("x",e,t,a),r=Xt("data",e,t,a),o=Xt("message",e,t,a),p=Xt("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<r.length;e++)console.log(Array.prototype.slice.call(r[e].dataSync()).slice(0,p));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"logical":return m((()=>((e,t,a)=>{switch(e.op){case"Equal":return[et(Xt("a",e,t,a),Xt("b",e,t,a))];case"NotEqual":return[Je(Xt("a",e,t,a),Xt("b",e,t,a))];case"Greater":return[Ye(Xt("a",e,t,a),Xt("b",e,t,a))];case"GreaterEqual":return[Ze(Xt("a",e,t,a),Xt("b",e,t,a))];case"Less":return[Xe(Xt("a",e,t,a),Xt("b",e,t,a))];case"LessEqual":return[Ke(Xt("a",e,t,a),Xt("b",e,t,a))];case"LogicalAnd":return[Qe(Xt("a",e,t,a),Xt("b",e,t,a))];case"LogicalNot":return[Ge(Xt("a",e,t,a))];case"LogicalOr":return[Ue(Xt("a",e,t,a),Xt("b",e,t,a))];case"Select":case"SelectV2":return[qe(Xt("condition",e,t,a),Xt("a",e,t,a),Xt("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"matrices":return m((()=>((e,t,a)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[nt(Xt("a",e,t,a),Xt("b",e,t,a),Xt("transposeA",e,t,a),Xt("transposeB",e,t,a))];case"Einsum":return[at(Xt("equation",e,t,a),...Xt("tensors",e,t,a))];case"Transpose":return[tt(Xt("x",e,t,a),Xt("perm",e,t,a))];case"_FusedMatMul":const[n,s]=Xt("fusedOps",e,t,a),r="biasadd"===n,o="prelu"===s,p=Xt("numArgs",e,t,a),i=Xt("leakyreluAlpha",e,t,a);if(r){if(o&&2!==p)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==p)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[m,u]=Xt("args",e,t,a);return[Se.matMul({a:Xt("a",e,t,a),b:Xt("b",e,t,a),transposeA:Xt("transposeA",e,t,a),transposeB:Xt("transposeB",e,t,a),bias:m,activation:s,preluActivationWeights:u,leakyreluAlpha:i})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"normalization":return m((()=>((e,t,a)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[it(Xt("x",e,t,a),Xt("mean",e,t,a),Xt("variance",e,t,a),Xt("offset",e,t,a),Xt("scale",e,t,a),Xt("epsilon",e,t,a))];case"LRN":return[pt(Xt("x",e,t,a),Xt("radius",e,t,a),Xt("bias",e,t,a),Xt("alpha",e,t,a),Xt("beta",e,t,a))];case"Softmax":return[ot(Xt("x",e,t,a))];case"LogSoftmax":return[rt(Xt("x",e,t,a))];case"SparseToDense":return[st(Xt("sparseIndices",e,t,a),Xt("outputShape",e,t,a),Xt("sparseValues",e,t,a),Xt("defaultValue",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"reduction":return m((()=>((e,t,a)=>{switch(e.op){case"Max":{const n=Xt("axis",e,t,a),s=Xt("keepDims",e,t,a);return[bt(Xt("x",e,t,a),n,s)]}case"Mean":{const n=Xt("axis",e,t,a),s=Xt("keepDims",e,t,a);return[gt(Xt("x",e,t,a),n,s)]}case"Min":{const n=Xt("axis",e,t,a),s=Xt("keepDims",e,t,a);return[Nt(Xt("x",e,t,a),n,s)]}case"Sum":{const n=Xt("axis",e,t,a),s=Xt("keepDims",e,t,a);return[ft(Xt("x",e,t,a),n,s)]}case"All":{const n=Xt("axis",e,t,a),s=Xt("keepDims",e,t,a);return[ht(Xt("x",e,t,a),n,s)]}case"Any":{const n=Xt("axis",e,t,a),s=Xt("keepDims",e,t,a);return[lt(Xt("x",e,t,a),n,s)]}case"ArgMax":{const n=Xt("axis",e,t,a);return[yt(Xt("x",e,t,a),n)]}case"ArgMin":{const n=Xt("axis",e,t,a);return[ct(Xt("x",e,t,a),n)]}case"Prod":{const n=Xt("axis",e,t,a),s=Xt("keepDims",e,t,a);return[I(Xt("x",e,t,a),n,s)]}case"Cumsum":{const n=Xt("axis",e,t,a),s=Xt("exclusive",e,t,a),r=Xt("reverse",e,t,a);return[dt(Xt("x",e,t,a),n,s,r)]}case"Bincount":const n=Xt("x",e,t,a),s=Xt("weights",e,t,a),r=Xt("size",e,t,a);return[ut(n,s,r)];case"DenseBincount":{const n=Xt("x",e,t,a),s=Xt("weights",e,t,a),r=Xt("size",e,t,a),o=Xt("binaryOutput",e,t,a);return[mt(n,s,r,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"slice_join":return m((()=>((t,a,n)=>{switch(t.op){case"ConcatV2":case"Concat":{const e=Xt("n",t,a,n),s=Xt("axis",t,a,n);let r=Xt("tensors",t,a,n);return r=r.slice(0,e),[Mt(r,s)]}case"Gather":{const e=Xt("x",t,a,n),s=Xt("indices",t,a,n);return[kt(e,$e(s,"int32"),0)]}case"GatherV2":{const e=Xt("axis",t,a,n),s=Xt("batchDims",t,a,n),r=Xt("x",t,a,n),o=Xt("indices",t,a,n);return[kt(r,$e(o,"int32"),e,s)]}case"Reverse":{const e=Xt("dims",t,a,n),s=[];for(let t=0;t<e.length;t++)e[t]&&s.push(t);const r=Xt("x",t,a,n);return[Dt(r,s)]}case"ReverseV2":{const e=Xt("axis",t,a,n),s=Xt("x",t,a,n);return[Dt(s,e)]}case"Slice":{const e=Xt("begin",t,a,n),s=Xt("size",t,a,n);return[It(Xt("x",t,a,n),e,s)]}case"StridedSlice":{const e=Xt("begin",t,a,n),s=Xt("end",t,a,n),r=Xt("strides",t,a,n),o=Xt("beginMask",t,a,n),p=Xt("endMask",t,a,n),i=Xt("ellipsisMask",t,a,n),m=Xt("newAxisMask",t,a,n),u=Xt("shrinkAxisMask",t,a,n),d=Xt("x",t,a,n);return[vt(d,e,s,r,o,p,i,m,u)]}case"Pack":return m((()=>{const s=Xt("axis",t,a,n),r=Xt("tensors",t,a,n),o=r[0].shape,p=wt(r[0]).shape,i=r.map((t=>{const a=e.arraysEqual(t.shape,o);if(!a&&!e.arraysEqual(wt(t).shape,p))throw new Error("the input tensors shape does not match");return a?t:At(t,o)}));return[Et(i,s)]}));case"Unpack":{const e=Xt("axis",t,a,n),s=Xt("tensor",t,a,n);return Ot(s,e)}case"Tile":{const e=Xt("reps",t,a,n);return[St(Xt("x",t,a,n),e)]}case"Split":case"SplitV":{const e=Xt("axis",t,a,n),s=Xt("numOrSizeSplits",t,a,n),r=Xt("x",t,a,n);return _t(r,s,e)}case"ScatterNd":{const e=Xt("indices",t,a,n),s=Xt("values",t,a,n),r=Xt("shape",t,a,n);return[Tt(e,s,r)]}case"GatherNd":{const e=Xt("x",t,a,n),s=Xt("indices",t,a,n);return[xt(e,s)]}case"SparseToDense":{const e=Xt("sparseIndices",t,a,n),s=Xt("outputShape",t,a,n),r=Xt("sparseValues",t,a,n),o=Xt("defaultValue",t,a,n);return[st(e,r,s,r.dtype===o.dtype?o:$e(o,r.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n)));case"spectral":return m((()=>((e,t,a)=>{switch(e.op){case"FFT":return[Lt(Xt("x",e,t,a))];case"IFFT":return[Ct(Xt("x",e,t,a))];case"RFFT":return[zt(Xt("x",e,t,a))];case"IRFFT":return[Vt(Xt("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"transformation":return m((()=>((e,t,a)=>{switch(e.op){case"Cast":return[$e(Xt("x",e,t,a),Xt("dtype",e,t,a))];case"ExpandDims":{const n=Xt("axis",e,t,a);return[Ht(Xt("x",e,t,a),n)]}case"Squeeze":{const n=Xt("axis",e,t,a);return[wt(Xt("x",e,t,a),n)]}case"Reshape":return[At(Xt("x",e,t,a),Xt("shape",e,t,a))];case"MirrorPad":return[Bt(Xt("x",e,t,a),Xt("padding",e,t,a),Xt("mode",e,t,a))];case"PadV2":case"Pad":return[Pt(Xt("x",e,t,a),Xt("padding",e,t,a),Xt("constantValue",e,t,a))];case"SpaceToBatchND":{const n=Xt("blockShape",e,t,a),s=Xt("paddings",e,t,a);return[jt(Xt("x",e,t,a),n,s)]}case"BatchToSpaceND":{const n=Xt("blockShape",e,t,a),s=Xt("crops",e,t,a);return[Rt(Xt("x",e,t,a),n,s)]}case"DepthToSpace":{const n=Xt("blockSize",e,t,a),s=Xt("dataFormat",e,t,a).toUpperCase();return[$t(Xt("x",e,t,a),n,s)]}case"BroadcastTo":return[Ft(Xt("x",e,t,a),Xt("shape",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"hash_table":return(async(e,t,a,n)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=Xt("keyDType",e,t,a),r=Xt("valueDType",e,t,a),o=new qa(s,r);return n.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=Xt("tableHandle",e,t,a,n),r=Xt("keys",e,t,a),o=Xt("values",e,t,a),p=n.getHashTableById(s.id);return[await p.import(r,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=Xt("tableHandle",e,t,a,n),r=Xt("keys",e,t,a),o=Xt("defaultValue",e,t,a),p=n.getHashTableById(s.id);return[await p.find(r,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=Xt("tableHandle",e,t,a,n);return[n.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n,s);case"custom":const r=Qt(t.op);if(r&&r.customExecutor)return r.customExecutor(new Ca(t,a,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,a,n);return e.isPromise(r)?r.then((e=>[].concat(e))):[].concat(r)}class Ga{constructor(e={},t={},a={},n={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=a,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Qa(e,t,a,n){const s=new Set,r=[];let o=null,p=null;const i=new Set,m=Object.keys(e).map((e=>ea(e)[0]));let u=[];null!=n&&(u=n.map((e=>ea(e.name)[0])));const d=[...t];for(;d.length>0;){const e=d.pop();(Ya(e)||Ja(e)||en(e))&&null==o&&(o=e,p=o.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==a[e.name]&&(-1===m.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{i.has(e.name)||(i.add(e.name),d.push(e))})):r.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:r,dynamicNode:o,syncInputs:p}}const Ka=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Xa=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Za=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Ya(e){return Ka.indexOf(e.op)>=0}function Ja(e){return Xa.indexOf(e.op)>=0}function en(e){return Za.indexOf(e.op)>=0}class tn{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new tn(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const a=e.map((e=>e.name)).sort(),n=t.map((e=>e.name)).sort();return a.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(e,t){const a=Qa(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:s,syncInputs:r}=a;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(n.length>0){const a=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${s}]. Missing the following inputs: [${n}]`)}return function(e,t,a){const{usedNodes:n,inputs:s}=a,r=[],o=Object.keys(s).map((e=>ea(e)[0])).map((t=>e.nodes[t])),p=e.initNodes;o.forEach((e=>{n.has(e.name)&&r.push(e)})),e.weights.forEach((e=>{n.has(e.name)&&r.push(e)})),null!=p&&p.forEach((e=>{n.has(e.name)&&r.push(e)}));const i=new Set,m=[];for(;r.length>0;){const e=r.pop();i.add(e.name),t[e.name]||m.push(e),e.children.forEach((e=>{!i.has(e.name)&&n.has(e.name)&&e.inputs.every((e=>i.has(e.name)))&&r.push(e)}))}return m}(this.graph,this.weightMap,a)}execute(t,a){t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),a=this.mapOutputs(a),this.checkOutputs(a);const s=n.map((e=>this.graph.nodes[ea(e)[0]])),r=a.map((e=>ea(e)[0]));let o=r.map((e=>this.graph.nodes[e]));0===o.length&&(o=this._outputs);const p=this.getCompilationKey(s,o);let i=this.compiledMap.get(p);null==i&&(i=this.compile(t,o),this.compiledMap.set(p,i));const u={},d={};return m((()=>{const n=new Ga(this.weightMap,u,d,this.functionExecutorMap),s=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[a,n]=ea(e),r=[];r[n]=t[e],s[a]=r}));const o=this.getFrozenTensorIds(s),p={};for(let t=0;t<i.length;t++){const a=i[t];if(!s[a.name]){const t=Ua(a,s,n,this._resourceManager);if(e.isPromise(t))throw new Error(`The execution of the op '${a.op}' returned a promise. Please use model.executeAsync() instead.`);s[a.name]=t,this.checkTensorForDisposal(a.name,a,s,n,o,r,p)}}return null==this.parent&&n.dispose(o),a.map((e=>Zt(e,s,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,a,n,s,r,o){"control"!==t.category&&-1===r.indexOf(e)&&(a[e].forEach((e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const t=function(e,t,a){return t[Jt(e,a.currentContextId)]}(e.name,a,n);null!=t&&t.forEach((e=>{if(e&&!e.kept&&!s.has(e.id)){const t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,a=!1,n={},s={}){a||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const r=new Ga(this.weightMap,n,s,this.functionExecutorMap),o=await this.executeWithControlFlow(e,r,t,a),p=t.map((e=>Zt(e,o,r))),i=p.map((e=>e.id)),m=Object.keys(e).map((t=>e[t].id)),u=new Set([...i,...m,...this.weightIds]);return Object.keys(o).forEach((e=>{o[e].forEach((e=>{!e||e.kept||e.isDisposed||u.has(e.id)||e.dispose()}))})),null==this.parent&&r.dispose(u),p}async executeFunctionAsync(e,t,a){const n=e.reduce(((e,t,a)=>(e[this.inputs[a].name]=t,e)),{});return this._executeAsync(n,this.outputNodes,!0,t,a)}async executeWithControlFlow(e,t,a,n){const s=Object.keys(e),r=s.map((e=>this.graph.nodes[ea(e)[0]])),o=a.map((e=>ea(e)[0]));let p=o.map((e=>this.graph.nodes[e]));0===p.length&&(p=this._outputs);const{usedNodes:i,missingInputs:m,dynamicNode:u,syncInputs:d}=Qa(e,p,this.weightMap,this._initNodes),c=[...r,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),y=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[a,n]=ea(t),s=[];s[n]=e[t],y[a]=s}));const l={},h=this.getFrozenTensorIds(y),f={};for(;c.length>0;){const e=this.processStack(r,c,t,y,f,h,o,l,i);await Promise.all(e)}null!=u||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=p.filter((e=>!Ya(e)&&!Zt(e.name,y,t))).map((e=>e.name));if(N.length>0){let e="";throw null!=u&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${s}]. Consider providing the following inputs: [${m}]. ${e}`)}return y}processStack(t,a,n,s,r,o,p,i,m){const u=[];for(;a.length>0;){const t=a.pop();n.currentContext=t.contexts;let d="";if("Enter"===t.node.op&&Xt("isConstant",t.node,s,n)&&([d]=Yt(t.node.name,n)),null==s[t.node.name]){const c=Ua(t.node,s,n,this._resourceManager);d||([d]=Yt(t.node.name,n));const y=n.currentContext;e.isPromise(c)?u.push(c.then((e=>(s[d]=e,n.currentContext=y,this.checkTensorForDisposal(d,t.node,s,n,o,p,i),this.processChildNodes(t.node,a,n,s,r,m),e)))):(s[d]=c,this.checkTensorForDisposal(d,t.node,s,n,o,p,i),this.processChildNodes(t.node,a,n,s,r,m))}else this.processChildNodes(t.node,a,n,s,r,m)}return u}processChildNodes(e,t,a,n,s,r){e.children.forEach((e=>{const[o]=Yt(e.name,a);!s[o]&&r.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Zt(e,n,a)))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every((e=>!!Zt(e,n,a)))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((a=>{const n=t[a],[s]=ea(a),r=this.graph.nodes[s];if(r.attrParams.shape&&r.attrParams.shape.value){const t=r.attrParams.shape.value,a=t.length===n.shape.length&&n.shape.every(((e,a)=>-1===t[a]||t[a]===e));e.assert(a,(()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`))}r.attrParams.dtype&&r.attrParams.dtype.value&&e.assert(n.dtype===r.attrParams.dtype.value,(()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){const t={};for(const a in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]){t[this._signature.inputs[a].name]=e[a]}else t[a]=e[a];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=ea(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=ea(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class an{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class nn{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new an}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=c.browserHTTPRequest(e,this.loadOptions);else{const t=c.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(c.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let a;a=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=a,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const n=c.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new tn(xa.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=xa.Instance.transformGraph(e.modelInitializer);this.initializer=new tn(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=c.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof y||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,a,n)=>(t[a]=e[n],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=this.executor.execute(e,t);return a.length>1?a:a[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=await this.executor.executeAsync(e,t);return a.length>1?a:a[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,a)=>(t[a]=[e[a]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function sn(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const a=new nn(e,t);return await a.load(),a}const rn="3.4.0";export{nn as GraphModel,Kt as deregisterOp,sn as loadGraphModel,Gt as registerOp,rn as version_converter};
//# sourceMappingURL=tf-converter.fesm.min.js.map
